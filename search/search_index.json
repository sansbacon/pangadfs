{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>pangadfs is a pandas-based (python) genetic algorithm framework for fantasy sports. It uses a plugin architecture to enable maximum flexibility while also providing a fully-functional implementation of a genetic algorithm for lineup optimization.</p> <p>Documentation: https://sansbacon.github.io/pangadfs/</p> <p>Source Code: https://github.com/sansbacon/pangadfs</p> <p>GUI Application: https://github.com/sansbacon/pangadfs-gui</p> <p>Version 0.2 Update</p> <p>Starting with version 0.2, the GUI application has been separated into its own repository for better modularity and easier maintenance. The core pangadfs library now focuses purely on the optimization algorithms.</p> <p>The key pangadfs features are:</p> <ul> <li>Fast: takes advantage of pandas and numpy to generate thousands of lineups quickly.</li> <li>Extensible: any desired functionality can be added with a straightforward plugin architecture.</li> <li>Pythonic: library is easy to use and extend as long as you are familiar with data analysis in python (pandas and numpy). You don't also have to be an expert in linear programming.</li> <li>Fewer bugs: Small core means fewer bugs and easier to trace code. Unlike other optimizers, pangadfs does not generate complicated equations behind the curtain that are difficult to comprehend and debug.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>pandas 1.0+</li> <li>numpy 1.19+</li> <li>stevedore 3.30+</li> <li>numpy-indexed 0.3+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install pangadfs\n</code></pre>"},{"location":"#example","title":"Example","text":""},{"location":"#create-it","title":"Create It","text":"<p>A simple pangadfs optimizer could look like the following</p> <pre><code>from pathlib import Path\nfrom pangadfs import GeneticAlgorithm\n\n    ctx = {\n        'ga_settings': {\n            'csvpth': Path(__file__).parent.parent / 'appdata' / 'pool.csv',\n            'n_generations': 20,\n            'population_size': 30000,\n            'stop_criteria': 10,\n            'verbose': True\n        },\n\n        'site_settings': {\n            'flex_positions': ('RB', 'WR', 'TE'),\n            'lineup_size': 9,\n            'posfilter': {'QB': 14, 'RB': 8, 'WR': 8, 'TE': 5, 'DST': 4, 'FLEX': 8},\n            'posmap': {'DST': 1, 'QB': 1, 'TE': 1, 'RB': 2, 'WR': 3, 'FLEX': 7},\n            'salary_cap': 50000\n        }\n    }\n\n    # set up GeneticAlgorithm object\n    ga = GeneticAlgorithm()\n\n    # create pool and pospool\n    pop_size = ctx['ga_settings']['population_size']\n    pool = ga.pool(csvpth=ctx['ga_settings']['csvpth'])\n    posfilter = ctx['site_settings']['posfilter']\n    flex_positions = ctx['site_settings']['flex_positions']\n    pospool = ga.pospool(pool=pool, posfilter=posfilter, column_mapping={}, flex_positions=flex_positions)\n\n    # create salary and points arrays\n    points = pool[cmap['proj']].values\n    salaries = pool[cmap['salary']].values\n\n    # create initial population\n    initial_population = ga.populate(\n        pospool=pospool, \n        posmap=ctx['site_settings']['posmap'], \n        population_size=pop_size\n    )\n\n    # apply validators (default are salary and duplicates)\n    initial_population = ga.validate(\n        population=initial_population, \n        salaries=salaries,\n        salary_cap=ctx['site_settings']['salary_cap']\n    )\n\n    population_fitness = ga.fitness(\n        population=initial_population, \n        points=points\n    )\n\n    # set overall_max based on initial population\n    omidx = population_fitness.argmax()\n    best_fitness = population_fitness[omidx]\n    best_lineup = initial_population[omidx]\n\n    # create new generations\n    n_unimproved = 0\n    population = initial_population.copy()\n\n    for i in range(1, ctx['ga_settings']['n_generations'] + 1):\n\n        # end program after n generations if not improving\n        if n_unimproved == ctx['ga_settings']['stop_criteria']:\n            break\n\n        # display progress information with verbose parameter\n        if ctx['ga_settings'].get('verbose'):\n            logging.info(f'Starting generation {i}')\n            logging.info(f'Best lineup score {best_fitness}')\n\n        # select the population\n        # here, we are holding back the fittest 20% to ensure\n        # that crossover and mutation do not overwrite good individuals\n        elite = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population) // ctx['ga_settings'].get('elite_divisor', 5),\n            method='fittest'\n        )\n\n        selected = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population),\n            method='roulette'\n        )\n\n        # cross over the population\n        crossed_over = ga.crossover(population=selected, method='uniform')\n\n        # mutate the crossed over population (leave elite alone)\n        mutated = ga.mutate(population=crossed_over, mutation_rate=.05)\n\n        # validate the population (elite + mutated)\n        population = ga.validate(\n            population=np.vstack((elite, mutated)), \n            salaries=salaries, \n            salary_cap=ctx['site_settings']['salary_cap']\n        )\n\n        # assess fitness and get the best score\n        population_fitness = ga.fitness(population=population, points=points)\n        omidx = population_fitness.argmax()\n        generation_max = population_fitness[omidx]\n\n        # if new best score, then set n_unimproved to 0\n        # and save the new best score and lineup\n        # otherwise increment n_unimproved\n        if generation_max &gt; best_fitness:\n            logging.info(f'Lineup improved to {generation_max}')\n            best_fitness = generation_max\n            best_lineup = population[omidx]\n            n_unimproved = 0\n        else:\n            n_unimproved += 1\n            logging.info(f'Lineup unimproved {n_unimproved} times')\n\n    # show best score and lineup at conclusion\n    print(pool.loc[best_lineup, :])\n    print(f'Lineup score: {best_fitness}')\n</code></pre>"},{"location":"#run-it","title":"Run it","text":"<p>Run the sample application with:</p> <pre><code>$ basicapp\n\nINFO:root:Starting generation 1\nINFO:root:Best lineup score 153.00000000000003\nINFO:root:Lineup unimproved 1 times\nINFO:root:Starting generation 2\nINFO:root:Best lineup score 153.00000000000003\nINFO:root:Lineup improved to 155.2\n. . . \nINFO:root:Starting generation 19\nINFO:root:Best lineup score 156.3\nINFO:root:Lineup improved to 156.5\nINFO:root:Starting generation 20\nINFO:root:Best lineup score 156.5\nINFO:root:Lineup unimproved 1 times\n\n               player team  pos  salary  proj\n0             Saints    NO  DST    3800   9.8\n34    Patrick Mahomes   KC   QB    8000  26.6\n62        Dalvin Cook  MIN   RB    9500  27.2\n68       Nyheim Hines  IND   RB    4600  15.9\n72         Brian Hill  ATL   RB    4000  12.8\n109     Gabriel Davis  BUF   WR    3000  10.7\n136   Keelan Cole Sr.  JAX   WR    3600  11.9\n138     Calvin Ridley  ATL   WR    7100  21.6\n142  Justin Jefferson  MIN   WR    6300  20.0\nLineup score: 156.5\n</code></pre>"},{"location":"#extensibility","title":"Extensibility","text":"<p>pangadfs is extensible by design and is motivated by difficulties I encountered with other optimizers, which tend to have a monolithic design and don't make it easy to swap out components. </p> <p>This flexibility is made possible by the stevedore plugin system, which allows allow applications to customize one or more of the internal components. </p> <p>As recommended by the stevedore documentation, the base module includes base classes to define each pluggable component. Each namespace has a default implementation (crossover, fitness, mutate, select, and so forth), which, collectively, provide a fully-functional implementation of a genetic algorithm.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"alternatives/","title":"Alternatives, Inspiration and Comparisons","text":"<p>pangadfs was inspired by my experience using web-based optimizers (WBOs), such as FantasyLabs and Rotogrinders, as well as python/R libraries for integer programming, such as google or-tools, PuLP, and lpSolve.</p> <p>There were a couple of things I did not like about WBOs: (1) they are a black box and (2) they use a rules-based approach to lineup construction. For most people, the WBOs enable them to do things they either lack the tecnhical ability to do, or, even if they have the requisite technical skills, they free them up to focus on creating lineups rather than debugging algorithms. I enjoy programming more than I enjoy creating lineups, and this is a fascinating domain in which to build my skills and test out ideas. I also found that the dominant paradigm for WBOs was a rules-based approach, meaning that you construct lineups by specifying a minimum and maximum ownership for individual players and requirements about combinations of players that are allowed or disallowed. To me, this puts the cart before the horse -- how can I know how to allocate ownership or what other rules to use before I see a range of lineup options. I think what ends up happening when you use these products is that you have intuitions (that may also be backed by data) that you encapsulate as a rule, and then you use other rules to try to cabin the side effects of your initial rule. For example, it is well known that QB performance has a strong positive correlation with WR1 scoring, so you create a stacking rule, but then every lineup ends up with the same QB-WR1 combination, so then you offset that with ownership rules. My experience was that I ended up with a very complex set (of seemingly arbitrary) rules and it was very difficult to administer at scale.</p> <p>Dissatisfied with web-based optimizers, I turned to python/R libraries for integer programming. After using these libraries (and those built on top of them, such as pydfs-lineup-optimizer), I faced a couple of frustrations. First, the user interface for some of them is, shall we say, less than optimal. For example, lpSolve required a vector of directions for constraints that became very difficult to manage or maintain as the number of variables or constraints grew. Second, even libraries that have a good interface, such as PuLP, still require you to learn an entirely different language of linear programming and then translate those concepts to python. I found that, as the number of constraints increased, it became very difficult to understand how the program was working under the hood. To boot, there are also performance problems the more constraints you add and as you want to generate more lineups. pydfs-lineup-optimizer is a well-designed library that takes away some of these issues, but, in the end, to make any meaningful contributions to the code, you need a very strong understanding of linear programming.</p> <p>As with many projects, I told myself \"there has to be a better way.\" I first had to find an alternative to linear programming as the core optimizer. I settled on a genetic algorithm because the concepts are easy to understand and it can be implemented in numpy, where vectorized operations allow for solid performance. Instead of having to learn an entirely different language (integer programming) and then translate it to python, I could write code in python / numpy.</p> <p>After learning more about genetic algorithms, I realized that they address my concerns (described above) about rule-based approaches. Instead of rules, genetic algorithms use penalties to nudge solutions in a particular direction. I also found out that they are excellent for quickly generating large numbers of viable lineups (making 10000 lineups is fast), whereas integer programming slows down the more lineups you try to generate. </p> <p>The last advantage I found was that the genetic algorithm is amenable to a plugin architecture. I found the stevedore plugin library, which allows me or other developers to create plugins to replace the core functionality of one or more steps of the genetic algorithm. This flexibility is straightforward, because at its core, the algorithm is passing 2D and 1D numpy arrays from function to function. I quickly developed plugins for showdown mode, a structured configuration system, and an interface to interact with pydfs-lineup-optimizer.</p> <p>These were my reasons for creating pangadfs. I look forward to your feedback and plugin ideas!</p>"},{"location":"base-reference/","title":"Workflow module","text":""},{"location":"base-reference/#pangadfs.base","title":"<code>pangadfs.base</code>","text":""},{"location":"base-reference/#pangadfs.base.CrossoverBase","title":"<code>CrossoverBase()</code>","text":"<p>Base class for crossover plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.CrossoverBase.crossover","title":"<code>crossover(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implement crossover.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef crossover(self, *args, **kwargs):\n    \"\"\"Implement crossover.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.FitnessBase","title":"<code>FitnessBase()</code>","text":"<p>Base class for fitness plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.FitnessBase.fitness","title":"<code>fitness(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implement fitness.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef fitness(self, *args, **kwargs):\n    \"\"\"Implement fitness.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.MutateBase","title":"<code>MutateBase()</code>","text":"<p>Base class for crossover plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.MutateBase.mutate","title":"<code>mutate(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Mutates population at given mutation rate.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef mutate(self, *args, **kwargs):\n    \"\"\"Mutates population at given mutation rate.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.OptimizeBase","title":"<code>OptimizeBase()</code>","text":"<p>Base class for optimize plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.OptimizeBase.optimize","title":"<code>optimize(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implements optimize.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef optimize(self, *args, **kwargs):\n    \"\"\"Implements optimize.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PenaltyBase","title":"<code>PenaltyBase()</code>","text":"<p>Base class for penalty plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PenaltyBase.penalty","title":"<code>penalty(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Calculates penalty for population fitness.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef penalty(self, *args, **kwargs):\n    \"\"\"Calculates penalty for population fitness.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PoolBase","title":"<code>PoolBase()</code>","text":"<p>Base class for pool plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PoolBase.pool","title":"<code>pool(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implement pool.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef pool(self, *args, **kwargs):\n    \"\"\"Implement pool.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PopulateBase","title":"<code>PopulateBase()</code>","text":"<p>Base class for populate plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PopulateBase.populate","title":"<code>populate(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Creates initial population from pool.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef populate(self, *args, **kwargs):\n    \"\"\"Creates initial population from pool.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PospoolBase","title":"<code>PospoolBase()</code>","text":"<p>Base class for pospool plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.PospoolBase.pospool","title":"<code>pospool(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implement pospool.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef pospool(self, *args, **kwargs):\n    \"\"\"Implement pospool.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.SelectBase","title":"<code>SelectBase()</code>","text":"<p>Base class for select plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.SelectBase.select","title":"<code>select(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implement select.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef select(self, *args, **kwargs):\n    \"\"\"Implement select.\"\"\"\n</code></pre>"},{"location":"base-reference/#pangadfs.base.ValidateBase","title":"<code>ValidateBase()</code>","text":"<p>Base class for validate plugins.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"base-reference/#pangadfs.base.ValidateBase.validate","title":"<code>validate(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implement validate.</p> Source code in <code>pangadfs/base.py</code> <pre><code>@abc.abstractmethod\ndef validate(self, *args, **kwargs):\n    \"\"\"Implement validate.\"\"\"\n</code></pre>"},{"location":"building-plugins/","title":"Developing pangadfs plugins","text":"<p>The best way to understand how to create a pangadfs plugin is to look at the structure and code of the existing pangadfs-showdown plugin. The default plugins for pangadfs will not gracefully handle \"Showdown\" (a/k/a \"Captain Mode\") contests on DraftKings. This plugin extends pangadfs to optimizes Showdown lineups.</p>"},{"location":"building-plugins/#plugin-namespaces","title":"Plugin Namespaces","text":"<p>The first step is to determine which plugin namespaces are required for your plugin. pangadfs-showdown provides classes for the following namespaces:</p> <ul> <li>pangadfs.pospool: ShowdownPospool</li> </ul> <p>The default pospool assumes a classic contest, where players are split into position groups along with a flex. The simplest way to handle showdown contests is to assume every player is a FLEX and then handle the 1.5x multiplier later.</p> <ul> <li>pangadfs.populate: ShowdownPopulate</li> </ul> <p>Populate works differently because there is no need for a separate FLEX draw. Instead, we just need to a random, unique draw of players to fill out a lineup.</p> <ul> <li>pangadfs.fitness: ShowdownFitness</li> </ul> <p>This handles the 1.5x multiplier for the first player (at index 0) when summing lineup points.</p> <ul> <li>pangadfs.validate: ShowdownSalaryValidate</li> </ul> <p>This handles the 1.5x multiplier for the first player (at index 0) when summing lineup salary.</p>"},{"location":"building-plugins/#loading-plugins","title":"Loading Plugins","text":"<p>It is advisable to provide an app that shows the proper configuration for your plugin. For pangadfs-showdown, the configuration is as follows:</p> <pre><code>    # setup context dict for configuration\n    ctx = {\n        'ga_settings': {\n            'crossover_method': 'uniform',\n            'csvpth': Path(__file__).parent / 'pool.csv',\n            'elite_divisor': 10,\n            'elite_method': 'fittest',\n            'mutation_rate': .10,\n            'n_generations': 20,\n            'points_column': 'proj',\n            'population_size': 5000,\n            'position_column': 'pos',\n            'salary_column': 'salary',\n            'select_method': 'diverse',\n            'stop_criteria': 10,\n            'verbose': True\n        },\n\n        'site_settings': {\n            'lineup_size': 6,\n            'posfilter': 2.0,\n            'salary_cap': 50000\n        }\n    }\n\n    # setup plugins\n    plugin_names = {\n      'pool': 'pool_default',\n      'pospool': 'pospool_showdown',\n      'populate': 'populate_showdown',\n      'optimize': 'optimize_default',\n      'crossover': 'crossover_default',\n      'mutate': 'mutate_default',\n      'fitness': 'fitness_showdown',\n      'select': 'select_default'\n    }\n\n    dmgrs = {ns: DriverManager(namespace=f'pangadfs.{ns}', name=pn, invoke_on_load=True)\n             for ns, pn in plugin_names.items()}\n\n    # when have multiple validators, need to use NamedExtensionManager so they all run\n    validate_names = ['salary_validate_showdown', 'validate_duplicates']\n    emgrs = {'validate': NamedExtensionManager('pangadfs.validate', names=validate_names, invoke_on_load=True)}\n\n    ga = GeneticAlgorithm(ctx=ctx, driver_managers=dmgrs, extension_managers=emgrs)\n</code></pre>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>The simplest way to get started with contributions is develop a plugin. Please follow the design structure of plugins such as pangadfs-showdown and pangadfs-configapp.</p> <p>The plugin architecture means that most feature requests should be developed through plugins, which means that no changes to pangadfs are needed to implement the feature. If you have ideas for how to improve the core pangadfs code, you can either open an issue or submit a pull request. Please format your code with yapf and use google-style docstrings. If we start to get contributions, I will develop more comprehensive guidelines, but for now these should suffice.</p>"},{"location":"crossover-reference/","title":"Crossover","text":""},{"location":"crossover-reference/#pangadfs.crossover","title":"<code>pangadfs.crossover</code>","text":""},{"location":"crossover-reference/#pangadfs.crossover.CrossoverDefault","title":"<code>CrossoverDefault()</code>","text":"<p>               Bases: <code>CrossoverBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"crossover-reference/#pangadfs.crossover.CrossoverDefault.crossover","title":"<code>crossover(*, population, method='uniform', **kwargs)</code>","text":"<p>Crossover individuals in population.</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population to crossover. Shape is n_individuals x n_chromosomes.</p> required <code>method</code> <code>str</code> <p>crossover method, 'uniform', 'diverse', 'one_point', or 'two_point'.</p> <code>'uniform'</code> <code>**kwargs</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: concatenation of two offspring</p> Source code in <code>pangadfs/crossover.py</code> <pre><code>def crossover(self, *, population: np.ndarray, method: str = 'uniform', **kwargs) -&gt; np.ndarray:\n    \"\"\"Crossover individuals in population.\n\n    Args:\n        population (np.ndarray): the population to crossover. Shape is n_individuals x n_chromosomes.\n        method (str): crossover method, 'uniform', 'diverse', 'one_point', or 'two_point'.\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        np.ndarray: concatenation of two offspring\n\n    \"\"\"     \n    dispatch = {\n        'uniform': self._uniform,\n        'diverse': self._diverse,\n        'one_point': self._one_point,\n        'two_point': self._two_point\n    }        \n\n    return dispatch.get(method, self._uniform)(population=population, **kwargs)\n</code></pre>"},{"location":"default-plugins/","title":"Default Plugins","text":"<p>pangadfs is motivated by my experience with other optimziers, which typically have a monolithic design and don't make it easy to swap out components. pangadfs uses the stevedore plugin system to allow applications to customize one or more of the internal components. There are default implementations of each plugin namespace, which provides a fully-functional implementation of a genetic algorithm. Other plugins can replace any or all of the defaults.</p> <p>As recommended by the stevedore documentation, the base module includes base classes to define each pluggable component. Plugins may, but are not required to subclass these base classes.</p>"},{"location":"default-plugins/#defaultpool","title":"DefaultPool","text":"<p>Reads in a csv file with columns: player, team, pos, salary, proj. Sorts players by position so indexes are sequential by position.</p> <pre><code>Usage:\n    fn = Path.home() / 'projections.csv'\n    pool = DefaultPool().pool(csvpth=fn)\n</code></pre>"},{"location":"default-plugins/#defaultpospool","title":"DefaultPospool","text":"<p>Creates prob (probabilities) column for weighted random sampling. Uses points per dollar to nudge initial selection to best options. While there are good reasons not to optimize solely on ppd, it is effective at creating a fit initial population.    </p> <pre><code>Usage:\n    fn = Path.home() / 'projections.csv'\n    pospool = DefaultPospool().pospool(\n      pool = DefaultPool().pool(csvpth=fn)\n      posfilter = {'QB': 12, 'RB': 8, 'WR': 8, 'TE': 5, 'DST': 4}\n    )\n</code></pre>"},{"location":"default-plugins/#defaultpopulate","title":"DefaultPopulate","text":"<p>This creates the initial population.</p>"},{"location":"default-plugins/#defaultcrossover","title":"DefaultCrossover","text":"<p>The default approach is to take the top percentile (default is pctl = 50) of the population and divide in half into father and mother. Then generate a boolean array of the same shape as the father and mother.</p> <p>Use the boolean array to generate two arrays of children:</p> <ul> <li>Child 1 takes from father on True and mother on False</li> <li>Child 2 takes from mother on True and father on False</li> </ul> <pre><code>Usage:\n    c = DefaultCrossover()\n    newpop = c.crossover(population=oldpop, population_fitness=oldpopfit, pctl=50)\n</code></pre>"},{"location":"default-plugins/#defaultmutate","title":"DefaultMutate","text":"<p>This mutates population acccording to the mutation rate.</p>"},{"location":"default-plugins/#salaryvalidate","title":"SalaryValidate","text":"<p>Ensures lineup does not exceed salary cap.</p>"},{"location":"default-plugins/#duplicatesvalidate","title":"DuplicatesValidate","text":"<p>Ensures lineup does not have duplicate players and that all lineups are unique.</p>"},{"location":"default-plugins/#default-optimize","title":"Default Optimize","text":"<p>Handles the basic optimization loop, coordinates pieces of genetic algorithm.</p>"},{"location":"features/","title":"Optimizing with Genetic Algorithms","text":""},{"location":"features/#basics-of-genetic-algorithms","title":"Basics of Genetic Algorithms","text":"<p>In principle, a population of individuals selected from the search space , often in a random manner, serves as candidate solutions to optimize the problem. The individuals in this population are evaluated through ( \"fitness\" ) adaptation function. A selection mechanism is then used to select individuals to be used as parents to those of the next generation. These individuals will then be crossed and mutated to form the new offspring. The next generation is finally formed by an alternative mechanism between parents and their offspring. This process is repeated until a certain satisfaction condition.</p> <p>Genetic algorithms maintain a population of candidate solutions, called individuals, for that given problem. These candidate solutions are iteratively evaluated and combined to create a new generation of solutions. Individuals with higher fitness (rated as better at solving the relevant problem) have a greater chance of being selected and passing their qualities to the next generation of candidate solutions This way, as generations go by, candidate solutions get better at solving the problem at hand.</p>"},{"location":"features/#optimizing-lineups-with-genetic-algorithms","title":"Optimizing Lineups with Genetic Algorithms","text":"<p>Applied to the context of daily fantasy lineups, a genetic algorithm works as follows:</p> <ul> <li> <p>Pool: load a pool of chromosomes (players) with position, salary, and points (projected if forward looking, actual points if historical).</p> </li> <li> <p>Pospool: segment the pool into positions. There will be duplicate genes (players) for multiposition eligibility / flex.</p> </li> <li> <p>Populate: create a population of individuals (here lineups) from a pool of genes (here player ids).</p> <ul> <li> <p>The initial populations are randomly created using weighted random sampling.</p> </li> <li> <p>Individauls are encoded as an array of integer IDs. For example, a DK NFL individual is np.array([dst_id, qb_id, rb_id, rb_id, wr_id, wr_id, wr_id, te_id, flex_id]).</p> </li> </ul> </li> <li> <p>Fitness: Assess the fitness of the population (is typically the sum of projected or actual points).</p> </li> <li> <p>Select: Discard low-performing individuals from the population.</p> </li> <li> <p>Crossover: create new individuals by randomly combining elements of the selected individuals.</p> </li> <li> <p>Mutate: randomly alter individuals by swapping out chromosomes.</p> </li> <li> <p>Validate: filter out invalid individuals (too much salary, duplicate chromosomes in individual, duplicate individuals in population, and so forth).</p> </li> <li> <p>Repeat for n generations (or until specified stop point, such as no improvement for 5 generations)</p> </li> </ul>"},{"location":"features/#using-penalties-instead-of-constraints","title":"Using Penalties Instead of Constraints","text":"<p>pangadfs allows the use of penalties rather than constraints. The intuition here is that you can nudge the optimizer toward a certain goal (lineup diversity, stacks, etc.) without creating arbitrary rules that may exclude the truly-optimal solutions.</p>"},{"location":"fitness-reference/","title":"Fitness","text":""},{"location":"fitness-reference/#pangadfs.fitness","title":"<code>pangadfs.fitness</code>","text":""},{"location":"fitness-reference/#pangadfs.fitness.FitnessDefault","title":"<code>FitnessDefault()</code>","text":"<p>               Bases: <code>FitnessBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"fitness-reference/#pangadfs.fitness.FitnessDefault.fitness","title":"<code>fitness(*, population, points, **kwargs)</code>","text":"<p>Assesses population fitness using supplied mapping</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population to assess fitness</p> required <code>points</code> <code>ndarray</code> <p>1D array of projected points in same order as pool</p> required <code>**kwargs</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <p>np.ndarray: 1D array of float</p> Source code in <code>pangadfs/fitness.py</code> <pre><code>def fitness(self,\n            *, \n            population: np.ndarray, \n            points: np.ndarray,\n            **kwargs):\n    \"\"\"Assesses population fitness using supplied mapping\n\n    Args:\n        population (np.ndarray): the population to assess fitness\n        points (np.ndarray): 1D array of projected points in same order as pool\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        np.ndarray: 1D array of float\n\n    \"\"\"\n    return np.sum(points[population], axis=1)\n</code></pre>"},{"location":"fitness-reference/#fitnessmultioptimizerfieldownership","title":"FitnessMultiOptimizerFieldOwnership","text":"<p>The <code>FitnessMultiOptimizerFieldOwnership</code> class is a fitness calculator for multi-objective optimization with field ownership. It calculates a composite fitness score based on three components: -   Score: The projected score of the lineups. -   Diversity: The uniqueness of the lineups compared to each other. -   Field Ownership: The projected ownership of the players in the lineups.</p> <p>The fitness function is a weighted sum of these three components. The weights can be configured in the <code>ga_settings</code> of the context object.</p>"},{"location":"fitness-reference/#fitness","title":"<code>fitness</code>","text":""},{"location":"fitness-reference/#pangadfs.fitness_multioptimizer_field_ownership.FitnessMultiOptimizerFieldOwnership.fitness","title":"<code>pangadfs.fitness_multioptimizer_field_ownership.FitnessMultiOptimizerFieldOwnership.fitness(population_sets, points, ownership, top_k, diversity_method, weights, strategy)</code>","text":"<p>Calculates the multi-objective fitness for each lineup set.</p> <p>Parameters:</p> Name Type Description Default <code>population_sets</code> <code>ndarray</code> <p>The population of lineup sets.</p> required <code>points</code> <code>ndarray</code> <p>The points for each player.</p> required <code>ownership</code> <code>ndarray</code> <p>The ownership for each player.</p> required <code>top_k</code> <code>int</code> <p>The number of top lineups to consider for the score component.</p> required <code>diversity_method</code> <code>str</code> <p>The method to calculate diversity.</p> required <code>weights</code> <code>tuple</code> <p>The weights for (score, diversity, ownership).</p> required <code>strategy</code> <code>str</code> <p>The ownership strategy ('contrarian', 'leverage', 'balanced').</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The fitness score for each lineup set.</p> Source code in <code>pangadfs/fitness_multioptimizer_field_ownership.py</code> <pre><code>def fitness(self,\n            population_sets: np.ndarray,\n            points: np.ndarray,\n            ownership: np.ndarray,\n            top_k: int,\n            diversity_method: str,\n            weights: tuple,\n            strategy: str) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the multi-objective fitness for each lineup set.\n\n    Args:\n        population_sets (np.ndarray): The population of lineup sets.\n        points (np.ndarray): The points for each player.\n        ownership (np.ndarray): The ownership for each player.\n        top_k (int): The number of top lineups to consider for the score component.\n        diversity_method (str): The method to calculate diversity.\n        weights (tuple): The weights for (score, diversity, ownership).\n        strategy (str): The ownership strategy ('contrarian', 'leverage', 'balanced').\n\n    Returns:\n        np.ndarray: The fitness score for each lineup set.\n    \"\"\"\n    score_weight, diversity_weight, ownership_weight = weights\n\n    # Calculate score component\n    lineup_scores = np.sum(points[population_sets], axis=2)\n    top_k_scores = np.sum(np.sort(lineup_scores, axis=1)[:, -top_k:], axis=1)\n    total_scores = np.sum(lineup_scores, axis=1)\n    score_component = top_k_scores + total_scores\n\n    # Calculate diversity component\n    diversity_component = self._calculate_diversity(population_sets, diversity_method)\n\n    # Calculate ownership component\n    ownership_component = self._calculate_ownership(population_sets, ownership, strategy)\n\n    # Normalize components\n    score_norm = self._normalize(score_component)\n    diversity_norm = self._normalize(diversity_component)\n    ownership_norm = self._normalize(ownership_component)\n\n    # Combined fitness\n    fitness = (score_weight * score_norm +\n               diversity_weight * diversity_norm +\n               ownership_weight * ownership_norm)\n\n    return fitness\n</code></pre>"},{"location":"history-design-future/","title":"Inspiration and Design","text":"<p>I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers.</p> <p>As part of that, I needed to investigate, test and use many alternatives.</p>"},{"location":"history-design-future/#design","title":"Design","text":"<p>Then I spent some time designing the developer \"API\" I wanted to have as a user (as a developer using FastAPI).</p> <p>I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors.</p> <p>By the last Python Developer Survey, that covers about 80% of the users.</p> <p>It means that FastAPI was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors.</p> <p>That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc.</p> <p>All in a way that provided the best development experience for all the developers.</p>"},{"location":"history-design-future/#future","title":"Future","text":"<p>By this point, it's already clear that FastAPI with its ideas is being useful for many people.</p> <p>It is being chosen over previous alternatives for suiting many use cases better.</p> <p>Many developers and teams already depend on FastAPI for their projects (including me and my team).</p> <p>But still, there are many improvements and features to come.</p> <p>FastAPI has a great future ahead.</p> <p>And your help is greatly appreciated.</p>"},{"location":"misc-reference/","title":"Miscellaneous","text":""},{"location":"misc-reference/#pangadfs.misc","title":"<code>pangadfs.misc</code>","text":""},{"location":"misc-reference/#pangadfs.misc.calculate_jaccard_diversity","title":"<code>calculate_jaccard_diversity(lineup1, lineup2)</code>","text":"<p>Calculate Jaccard diversity between two lineups</p> <p>Parameters:</p> Name Type Description Default <code>lineup1</code> <p>First lineup (array-like of player IDs)</p> required <code>lineup2</code> <p>Second lineup (array-like of player IDs)</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Jaccard diversity (1 - Jaccard similarity)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lineup1 = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; lineup2 = [1, 2, 6, 7, 8]\n&gt;&gt;&gt; diversity = calculate_jaccard_diversity(lineup1, lineup2)\n&gt;&gt;&gt; print(f\"Diversity: {diversity:.3f}\")\nDiversity: 0.667\n</code></pre> Source code in <code>pangadfs/misc.py</code> <pre><code>def calculate_jaccard_diversity(lineup1, lineup2):\n    \"\"\"Calculate Jaccard diversity between two lineups\n\n    Args:\n        lineup1: First lineup (array-like of player IDs)\n        lineup2: Second lineup (array-like of player IDs)\n\n    Returns:\n        float: Jaccard diversity (1 - Jaccard similarity)\n\n    Examples:\n        &gt;&gt;&gt; lineup1 = [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; lineup2 = [1, 2, 6, 7, 8]\n        &gt;&gt;&gt; diversity = calculate_jaccard_diversity(lineup1, lineup2)\n        &gt;&gt;&gt; print(f\"Diversity: {diversity:.3f}\")\n        Diversity: 0.667\n    \"\"\"\n    set1 = set(lineup1)\n    set2 = set(lineup2)\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    similarity = intersection / union if union &gt; 0 else 0.0\n    return 1.0 - similarity  # diversity = 1 - similarity\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.diversity","title":"<code>diversity(population)</code>","text":"<p>Calculates diversity of lineups</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: is square, shape len(population) x len(population)</p> Source code in <code>pangadfs/misc.py</code> <pre><code>def diversity(population: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Calculates diversity of lineups\n\n    Args:\n        population (np.ndarray): the population\n\n    Returns:\n        np.ndarray: is square, shape len(population) x len(population)\n\n    \"\"\"\n    uniques = np.unique(population)\n    a = (population[..., None] == uniques).sum(1)\n    return np.einsum('ij,kj-&gt;ik', a, a)\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.diversity_optimized","title":"<code>diversity_optimized(population)</code>","text":"<p>Calculates pairwise diversity between samples (overlap of player IDs).</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>shape (N, K), where each row is a lineup</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: shape (N, N), matrix of pairwise overlap scores</p> Source code in <code>pangadfs/misc.py</code> <pre><code>def diversity_optimized(population: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculates pairwise diversity between samples (overlap of player IDs).\n\n    Args:\n        population (np.ndarray): shape (N, K), where each row is a lineup\n\n    Returns:\n        np.ndarray: shape (N, N), matrix of pairwise overlap scores\n    \"\"\"\n    uniques, inverse = np.unique(population, return_inverse=True)\n    N, K = population.shape\n    U = len(uniques)\n\n    # Construct count matrix a: shape (N, U)\n    a = np.zeros((N, U), dtype=np.uint8)\n    rows = np.repeat(np.arange(N), K)\n    np.add.at(a, (rows, inverse), 1)\n\n    # Pairwise dot product: overlap between lineups\n    return a @ a.T\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.exposure","title":"<code>exposure(population=None)</code>","text":"<p>Returns dict of index: count of individuals</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[int, int]</code> <p>Dict[int, int]: key is index, value is count of lineup</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fittest_population = population[np.where(fitness &gt; np.percentile(fitness, 97))]\n&gt;&gt;&gt; exposure = population_exposure(fittest_population)\n&gt;&gt;&gt; top_exposure = np.argpartition(np.array(list(exposure.values())), -10)[-10:]\n&gt;&gt;&gt; print([round(i, 3) for i in sorted(top_exposure / len(fittest_population), reverse=True)])\n</code></pre> Source code in <code>pangadfs/misc.py</code> <pre><code>def exposure(population: np.ndarray = None) -&gt; Dict[int, int]:\n    \"\"\"Returns dict of index: count of individuals\n\n    Args:\n        population (np.ndarray): the population\n\n    Returns:\n        Dict[int, int]: key is index, value is count of lineup\n\n    Examples:\n        &gt;&gt;&gt; fittest_population = population[np.where(fitness &gt; np.percentile(fitness, 97))]\n        &gt;&gt;&gt; exposure = population_exposure(fittest_population)\n        &gt;&gt;&gt; top_exposure = np.argpartition(np.array(list(exposure.values())), -10)[-10:]\n        &gt;&gt;&gt; print([round(i, 3) for i in sorted(top_exposure / len(fittest_population), reverse=True)])            \n\n    \"\"\"\n    flat = population.flatten\n    return dict(zip(flat, np.bincount(flat)[flat]))\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.multidimensional_shifting","title":"<code>multidimensional_shifting(elements, num_samples, sample_size, probs)</code>","text":"<p>Based on https://medium.com/ibm-watson/incredibly-fast-random-sampling-in-python-baf154bd836a</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>iterable</code> <p>iterable to sample from, typically a dataframe index</p> required <code>num_samples</code> <code>int</code> <p>the number of rows (e.g. initial population size)</p> required <code>sample_size</code> <code>int</code> <p>the number of columns (e.g. team size)</p> required <code>probs</code> <code>iterable</code> <p>is same size as elements</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>of shape (num_samples, sample_size)</p> Source code in <code>pangadfs/misc.py</code> <pre><code>def multidimensional_shifting(elements: Iterable, \n                              num_samples: int, \n                              sample_size: int, \n                              probs: Iterable) -&gt; np.ndarray:\n    \"\"\"Based on https://medium.com/ibm-watson/incredibly-fast-random-sampling-in-python-baf154bd836a\n\n    Args:\n        elements (iterable): iterable to sample from, typically a dataframe index\n        num_samples (int): the number of rows (e.g. initial population size)\n        sample_size (int): the number of columns (e.g. team size)\n        probs (iterable): is same size as elements\n\n    Returns:\n        ndarray: of shape (num_samples, sample_size)\n\n    \"\"\"\n    replicated_probabilities = np.tile(probs, (num_samples, 1))\n    random_shifts = np.random.random(replicated_probabilities.shape)\n    random_shifts /= random_shifts.sum(axis=1)[:, np.newaxis]\n    shifted_probabilities = random_shifts - replicated_probabilities\n    samples = np.argpartition(shifted_probabilities, sample_size, axis=1)[:, :sample_size]\n    return elements.to_numpy()[samples]\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.multidimensional_shifting_fast","title":"<code>multidimensional_shifting_fast(num_samples, sample_size, probs, elements=None)</code>","text":"<p>High-performance probabilistic sampling using random shifting.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of sample rows to generate.</p> required <code>sample_size</code> <code>int</code> <p>Number of items to select per row.</p> required <code>probs</code> <code>ndarray</code> <p>Probability vector of shape (n_elements,), dtype float32 recommended.</p> required <code>elements</code> <code>ndarray</code> <p>Optional array of element IDs (defaults to np.arange(len(probs))).</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (num_samples, sample_size)</p> Source code in <code>pangadfs/misc.py</code> <pre><code>def multidimensional_shifting_fast(\n    num_samples: int,\n    sample_size: int,\n    probs: np.ndarray,\n    elements: np.ndarray = None\n) -&gt; np.ndarray:\n    \"\"\"\n    High-performance probabilistic sampling using random shifting.\n\n    Args:\n        num_samples: Number of sample rows to generate.\n        sample_size: Number of items to select per row.\n        probs: Probability vector of shape (n_elements,), dtype float32 recommended.\n        elements: Optional array of element IDs (defaults to np.arange(len(probs))).\n\n    Returns:\n        np.ndarray of shape (num_samples, sample_size)\n    \"\"\"\n    if elements is None:\n        elements = np.arange(len(probs))\n    else:\n        elements = np.asarray(elements)\n\n    probs = np.asarray(probs, dtype=np.float32)\n    rand = np.random.random((num_samples, len(probs))).astype(np.float32)\n    rand /= rand.sum(axis=1, keepdims=True)\n\n    shifted = rand - probs\n    idx = np.argpartition(shifted, sample_size - 1, axis=1)[:, :sample_size]\n\n    return elements[idx]\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.multidimensional_shifting_numba","title":"<code>multidimensional_shifting_numba(num_samples, sample_size, probs, elements=None)</code>","text":"<p>Numba-accelerated version of multidimensional shifting. Fast for large numbers of samples and small element sets.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of rows to sample.</p> required <code>sample_size</code> <code>int</code> <p>Number of items per sample.</p> required <code>probs</code> <code>ndarray</code> <p>Probability vector of shape (n_elements,).</p> required <code>elements</code> <code>ndarray</code> <p>IDs to sample from. Defaults to np.arange(len(probs)).</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: shape (num_samples, sample_size)</p> Source code in <code>pangadfs/misc.py</code> <pre><code>def multidimensional_shifting_numba(\n    num_samples: int,\n    sample_size: int,\n    probs: np.ndarray,\n    elements: np.ndarray = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated version of multidimensional shifting.\n    Fast for large numbers of samples and small element sets.\n\n    Args:\n        num_samples (int): Number of rows to sample.\n        sample_size (int): Number of items per sample.\n        probs (np.ndarray): Probability vector of shape (n_elements,).\n        elements (np.ndarray, optional): IDs to sample from. Defaults to np.arange(len(probs)).\n\n    Returns:\n        np.ndarray: shape (num_samples, sample_size)\n    \"\"\"\n    if elements is None:\n        elements = np.arange(len(probs))\n    else:\n        elements = np.asarray(elements)\n\n    probs = np.asarray(probs, dtype=np.float32)\n    indices = _generate_shifted_indices(probs, num_samples, sample_size)\n    return elements[indices]\n</code></pre>"},{"location":"misc-reference/#pangadfs.misc.parents","title":"<code>parents(population)</code>","text":"<p>Evenly splits population</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population to crossover. Shape is n_individuals x n_chromosomes.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: population split into two equal-size arrays</p> Source code in <code>pangadfs/misc.py</code> <pre><code>def parents(population: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Evenly splits population\n\n    Args:\n        population (np.ndarray): the population to crossover. Shape is n_individuals x n_chromosomes.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: population split into two equal-size arrays\n\n    \"\"\"\n    fathers, mothers = np.array_split(population, 2)\n    size = min(len(fathers), len(mothers))\n    return fathers[:size], mothers[:size]\n</code></pre>"},{"location":"mutate-reference/","title":"Mutation","text":""},{"location":"mutate-reference/#pangadfs.mutate","title":"<code>pangadfs.mutate</code>","text":""},{"location":"mutate-reference/#pangadfs.mutate.MutateDefault","title":"<code>MutateDefault()</code>","text":"<p>               Bases: <code>MutateBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"mutate-reference/#pangadfs.mutate.MutateDefault.mutate","title":"<code>mutate(*, population, mutation_rate=0.05)</code>","text":"<p>Mutates individuals in population</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population to mutate. Shape is n_individuals x n_chromosomes.</p> required <code>mutation_rate</code> <code>float</code> <p>decimal value from 0 to 1, default .05</p> <code>0.05</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: same shape as population</p> Source code in <code>pangadfs/mutate.py</code> <pre><code>def mutate(self, *, population: np.ndarray, mutation_rate: float = .05) -&gt; np.ndarray:\n    \"\"\"Mutates individuals in population\n\n    Args:\n        population (np.ndarray): the population to mutate. Shape is n_individuals x n_chromosomes.\n        mutation_rate (float): decimal value from 0 to 1, default .05\n\n    Returns:\n        np.ndarray: same shape as population\n\n    \"\"\"\n    # mutate is ndarray of same shape of population of dtype bool\n    # if mutation_rate is .05, then 1 out of 20 values should be True\n    # where mutate is true, swap randomly-selected player into population\n    # ensures swap comes from same lineup slot, but does not prevent duplicates from other slots\n    # so lineup positional allocation will stay valid, but duplicates are possible\n    mutate = (\n        np.random.binomial(n=1, p=mutation_rate, size=population.size)\n        .reshape(population.shape)\n        .astype(bool)\n    )\n    swap = population[np.random.choice(len(population), size=len(population), replace=False)]\n    return np.where(mutate, swap, population)\n</code></pre>"},{"location":"optimize-reference/","title":"Optimization","text":""},{"location":"optimize-reference/#pangadfs.optimize","title":"<code>pangadfs.optimize</code>","text":""},{"location":"optimize-reference/#pangadfs.optimize.OptimizeDefault","title":"<code>OptimizeDefault()</code>","text":"<p>               Bases: <code>OptimizeBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"optimize-reference/#pangadfs.optimize.OptimizeDefault.optimize","title":"<code>optimize(ga, **kwargs)</code>","text":"<p>Creates initial pool</p> <p>Parameters:</p> Name Type Description Default <code>ga</code> <code>GeneticAlgorithm</code> <p>the ga instance</p> required <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict</p> <code>Dict[str, Any]</code> <p>'population': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'fitness': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'best_lineup': pd.DataFrame,</p> <code>Dict[str, Any]</code> <p>'best_score': float</p> Source code in <code>pangadfs/optimize.py</code> <pre><code>def optimize(self, ga: GeneticAlgorithm, **kwargs) -&gt; Dict[str, Any]:\n    \"\"\"Creates initial pool\n\n    Args:\n        ga (GeneticAlgorithm): the ga instance\n        **kwargs: keyword arguments for plugins\n\n    Returns:\n        Dict\n        'population': np.ndarray,\n        'fitness': np.ndarray,\n        'best_lineup': pd.DataFrame,\n        'best_score': float\n\n    \"\"\"\n    # Start profiling\n    ga.profiler.start_optimization()\n    # create pool and pospool\n    # pospool used to generate initial population\n    # is a dict of position_name: DataFrame\n    pop_size = ga.ctx['ga_settings']['population_size']\n    pool = ga.pool(csvpth=ga.ctx['ga_settings']['csvpth'])\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'position': ga.ctx['ga_settings']['position_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    posfilter = ga.ctx['site_settings']['posfilter']\n    flex_positions = ga.ctx['site_settings']['flex_positions']\n    pospool = ga.pospool(pool=pool, posfilter=posfilter, column_mapping=cmap, flex_positions=flex_positions)\n\n    # create salary and points arrays\n    # these match indices of pool\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    points = pool[cmap['points']].values\n    salaries = pool[cmap['salary']].values\n\n    # create initial population\n    initial_population = ga.populate(\n        pospool=pospool, \n        posmap=ga.ctx['site_settings']['posmap'], \n        population_size=pop_size\n    )\n\n    # apply validators\n    # default is to validate duplicates, salary, and positions\n    # can add other validators as desired\n    initial_population = ga.validate(\n        population=initial_population, \n        salaries=salaries,\n        salary_cap=ga.ctx['site_settings']['salary_cap'],\n        pool=pool,\n        posmap=ga.ctx['site_settings']['posmap'],\n        position_column=ga.ctx['ga_settings']['position_column'],\n        flex_positions=ga.ctx['site_settings']['flex_positions']\n    )\n\n    # need fitness to determine best lineup\n    # and also for selection when loop starts\n    population_fitness = ga.fitness(\n        population=initial_population, \n        points=points\n    )\n\n    # set overall_max based on initial population\n    omidx = population_fitness.argmax()\n    best_fitness = population_fitness[omidx]\n    best_lineup = initial_population[omidx]\n\n    # Mark setup phase complete\n    ga.profiler.mark_setup_complete()\n\n    # Mark initial best solution (generation 0)\n    ga.profiler.mark_best_solution(0)\n\n    # create new generations\n    n_unimproved = 0\n    population = initial_population.copy()\n\n    for i in range(1, ga.ctx['ga_settings']['n_generations'] + 1):\n        # Start generation timing\n        ga.profiler.start_generation(i)\n\n        # end program after n generations if not improving\n        if n_unimproved == ga.ctx['ga_settings']['stop_criteria']:\n            break\n\n        # display progress information with verbose parameter\n        if ga.ctx['ga_settings'].get('verbose'):\n            logging.info(f'Starting generation {i}')\n            logging.info(f'Best lineup score {best_fitness}')\n\n        # select the population\n        # here, we are holding back the fittest 20% to ensure\n        # that crossover and mutation do not overwrite good individuals\n        elite = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population) // ga.ctx['ga_settings'].get('elite_divisor', 5),\n            method=ga.ctx['ga_settings'].get('elite_method', 'fittest')\n        )\n\n        selected = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population),\n            method=ga.ctx['ga_settings'].get('select_method', 'roulette')\n        )\n\n        # cross over the population\n        # here, we use uniform crossover, which splits the population\n        # and randomly exchanges 0 - all chromosomes\n        crossed_over = ga.crossover(population=selected, method=ga.ctx['ga_settings'].get('crossover_method', 'uniform'))\n\n        # mutate the crossed over population (leave elite alone)\n        # can use fixed rate or variable to reduce mutation over generations\n        # here we use a variable rate that increases if no improvement is found\n        mutation_rate = ga.ctx['ga_settings'].get('mutation_rate', max(.05, n_unimproved / 50))\n        mutated = ga.mutate(population=crossed_over, mutation_rate=mutation_rate)\n\n        # validate the population (elite + mutated)\n        population = ga.validate(\n            population=np.vstack((elite, mutated)), \n            salaries=salaries, \n            salary_cap=ga.ctx['site_settings']['salary_cap'],\n            pool=pool,\n            posmap=ga.ctx['site_settings']['posmap'],\n            position_column=ga.ctx['ga_settings']['position_column'],\n            flex_positions=ga.ctx['site_settings']['flex_positions']\n        )\n\n        # assess fitness and get the best score\n        population_fitness = ga.fitness(population=population, points=points)\n        omidx = population_fitness.argmax()\n        generation_max = population_fitness[omidx]\n\n        # if new best score, then set n_unimproved to 0\n        # and save the new best score and lineup\n        # otherwise increment n_unimproved\n        if generation_max &gt; best_fitness:\n            logging.info(f'Lineup improved to {generation_max}')\n            best_fitness = generation_max\n            best_lineup = population[omidx]\n            n_unimproved = 0\n            # Mark when best solution was found\n            ga.profiler.mark_best_solution(i)\n        else:\n            n_unimproved += 1\n            logging.info(f'Lineup unimproved {n_unimproved} times')\n\n        # End generation timing\n        ga.profiler.end_generation()\n\n    # End profiling\n    ga.profiler.end_optimization()\n\n    # FINALIZE RESULTS\n    # will break after n_generations or when stop_criteria reached\n    results = {\n        'population': population,\n        'fitness': population_fitness,\n        'best_lineup': pool.loc[best_lineup, :],\n        'best_score': best_fitness\n    }\n\n    # Add profiling data to results\n    if ga.profiler.enabled:\n        results['profiling'] = ga.profiler.export_to_dict()\n\n    return results\n</code></pre>"},{"location":"optimize-reference/#pangadfs.optimize.OptimizeMultilineup","title":"<code>OptimizeMultilineup()</code>","text":"<p>               Bases: <code>OptimizeBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"optimize-reference/#pangadfs.optimize.OptimizeMultilineup.optimize","title":"<code>optimize(ga, **kwargs)</code>","text":"<p>Optimizes for multiple diverse lineups</p> <p>Parameters:</p> Name Type Description Default <code>ga</code> <code>GeneticAlgorithm</code> <p>the ga instance</p> required <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing:</p> <code>Dict[str, Any]</code> <p>'population': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'fitness': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'best_lineup': pd.DataFrame,  # For backward compatibility</p> <code>Dict[str, Any]</code> <p>'best_score': float,          # For backward compatibility</p> <code>Dict[str, Any]</code> <p>'lineups': List[pd.DataFrame], # Multiple lineups</p> <code>Dict[str, Any]</code> <p>'scores': List[float],        # Corresponding scores</p> <code>Dict[str, Any]</code> <p>'diversity_metrics': Dict     # Diversity statistics</p> Source code in <code>pangadfs/optimize.py</code> <pre><code>def optimize(self, ga: GeneticAlgorithm, **kwargs) -&gt; Dict[str, Any]:\n    \"\"\"Optimizes for multiple diverse lineups\n\n    Args:\n        ga (GeneticAlgorithm): the ga instance\n        **kwargs: keyword arguments for plugins\n\n    Returns:\n        Dict containing:\n        'population': np.ndarray,\n        'fitness': np.ndarray,\n        'best_lineup': pd.DataFrame,  # For backward compatibility\n        'best_score': float,          # For backward compatibility\n        'lineups': List[pd.DataFrame], # Multiple lineups\n        'scores': List[float],        # Corresponding scores\n        'diversity_metrics': Dict     # Diversity statistics\n\n    \"\"\"\n    # Get multilineup settings with defaults\n    target_lineups = ga.ctx['ga_settings'].get('target_lineups', 1)\n    diversity_weight = ga.ctx['ga_settings'].get('diversity_weight', 0.2)\n    min_overlap_threshold = ga.ctx['ga_settings'].get('min_overlap_threshold', 0.4)  # More aggressive default\n    diversity_method = ga.ctx['ga_settings'].get('diversity_method', 'jaccard')\n\n    # Start profiling\n    ga.profiler.start_optimization()\n\n    # Create pool and pospool (same as OptimizeDefault)\n    pop_size = ga.ctx['ga_settings']['population_size']\n    pool = ga.pool(csvpth=ga.ctx['ga_settings']['csvpth'])\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'position': ga.ctx['ga_settings']['position_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    posfilter = ga.ctx['site_settings']['posfilter']\n    flex_positions = ga.ctx['site_settings']['flex_positions']\n    pospool = ga.pospool(pool=pool, posfilter=posfilter, column_mapping=cmap, flex_positions=flex_positions)\n\n    # Create salary and points arrays\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    points = pool[cmap['points']].values\n    salaries = pool[cmap['salary']].values\n\n    # Create initial population\n    initial_population = ga.populate(\n        pospool=pospool, \n        posmap=ga.ctx['site_settings']['posmap'], \n        population_size=pop_size\n    )\n\n    # Apply validators\n    initial_population = ga.validate(\n        population=initial_population, \n        salaries=salaries,\n        salary_cap=ga.ctx['site_settings']['salary_cap'],\n        pool=pool,\n        posmap=ga.ctx['site_settings']['posmap'],\n        position_column=ga.ctx['ga_settings']['position_column'],\n        flex_positions=ga.ctx['site_settings']['flex_positions']\n    )\n\n    # Calculate fitness\n    population_fitness = ga.fitness(\n        population=initial_population, \n        points=points\n    )\n\n    # Set overall_max based on initial population\n    omidx = population_fitness.argmax()\n    best_fitness = population_fitness[omidx]\n    best_lineup = initial_population[omidx]\n\n    # Mark setup phase complete\n    ga.profiler.mark_setup_complete()\n\n    # Mark initial best solution (generation 0)\n    ga.profiler.mark_best_solution(0)\n\n    # Create new generations (same GA loop as OptimizeDefault)\n    n_unimproved = 0\n    population = initial_population.copy()\n\n    for i in range(1, ga.ctx['ga_settings']['n_generations'] + 1):\n        # Start generation timing\n        ga.profiler.start_generation(i)\n\n        # End program after n generations if not improving\n        if n_unimproved == ga.ctx['ga_settings']['stop_criteria']:\n            break\n\n        # Display progress information with verbose parameter\n        if ga.ctx['ga_settings'].get('verbose'):\n            logging.info(f'Starting generation {i}')\n            logging.info(f'Best lineup score {best_fitness}')\n\n        # Select the population\n        elite = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population) // ga.ctx['ga_settings'].get('elite_divisor', 5),\n            method=ga.ctx['ga_settings'].get('elite_method', 'fittest')\n        )\n\n        selected = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population),\n            method=ga.ctx['ga_settings'].get('select_method', 'roulette')\n        )\n\n        # Cross over the population\n        crossed_over = ga.crossover(population=selected, method=ga.ctx['ga_settings'].get('crossover_method', 'uniform'))\n\n        # Mutate the crossed over population\n        mutation_rate = ga.ctx['ga_settings'].get('mutation_rate', max(.05, n_unimproved / 50))\n        mutated = ga.mutate(population=crossed_over, mutation_rate=mutation_rate)\n\n        # Validate the population\n        population = ga.validate(\n            population=np.vstack((elite, mutated)), \n            salaries=salaries, \n            salary_cap=ga.ctx['site_settings']['salary_cap'],\n            pool=pool,\n            posmap=ga.ctx['site_settings']['posmap'],\n            position_column=ga.ctx['ga_settings']['position_column'],\n            flex_positions=ga.ctx['site_settings']['flex_positions']\n        )\n\n        # Assess fitness and get the best score\n        population_fitness = ga.fitness(population=population, points=points)\n        omidx = population_fitness.argmax()\n        generation_max = population_fitness[omidx]\n\n        # If new best score, then set n_unimproved to 0\n        if generation_max &gt; best_fitness:\n            logging.info(f'Lineup improved to {generation_max}')\n            best_fitness = generation_max\n            best_lineup = population[omidx]\n            n_unimproved = 0\n            # Mark when best solution was found\n            ga.profiler.mark_best_solution(i)\n        else:\n            n_unimproved += 1\n            logging.info(f'Lineup unimproved {n_unimproved} times')\n\n        # End generation timing\n        ga.profiler.end_generation()\n\n    # End profiling\n    ga.profiler.end_optimization()\n\n    # MULTILINEUP SELECTION\n    # Select diverse lineups from final population\n    if target_lineups == 1:\n        # Single lineup mode - return same structure as OptimizeDefault\n        selected_lineups = [population[omidx]]\n        selected_scores = [best_fitness]\n        diversity_metrics = {'avg_overlap': 0.0, 'min_overlap': 0.0, 'diversity_matrix': np.array([[1.0]])}\n    else:\n        # Multiple lineup mode - select diverse lineups\n        selected_lineups, selected_scores, diversity_metrics = self._select_diverse_lineups(\n            population, population_fitness, target_lineups, diversity_weight, min_overlap_threshold, diversity_method\n        )\n\n    # FINALIZE RESULTS\n    results = {\n        'population': population,\n        'fitness': population_fitness,\n        'best_lineup': pool.loc[best_lineup, :],  # Backward compatibility\n        'best_score': best_fitness,               # Backward compatibility\n        'lineups': [pool.loc[lineup, :] for lineup in selected_lineups],\n        'scores': selected_scores,\n        'diversity_metrics': diversity_metrics\n    }\n\n    # Add profiling data to results\n    if ga.profiler.enabled:\n        results['profiling'] = ga.profiler.export_to_dict()\n\n    return results\n</code></pre>"},{"location":"optimize-reference/#optimizemultioptimizerfieldownership","title":"OptimizeMultiOptimizerFieldOwnership","text":"<p>The <code>OptimizeMultiOptimizerFieldOwnership</code> class is an advanced multi-optimizer that balances three key objectives: -   Score optimization: Prioritizes both the best-performing lineups and the overall quality of the entire lineup set. -   Diversity: Ensures that the generated lineups are different from each other, reducing overlap and increasing the chances of a unique lineup winning. -   Field ownership differentiation: Provides a strategic edge by considering the projected ownership of players in the field. This can be used to create contrarian lineups that avoid popular players or to leverage low-owned players with high upside.</p>"},{"location":"optimize-reference/#configuration","title":"Configuration","text":"<p>The behavior of the optimizer can be controlled through the <code>ga_settings</code> in the context object.</p> Setting Description Default <code>target_lineups</code> The number of lineups to generate. <code>10</code> <code>score_weight</code> The weight to give to the score component of the fitness function. <code>0.5</code> <code>diversity_weight</code> The weight to give to the diversity component of the fitness function. <code>0.3</code> <code>field_ownership_weight</code> The weight to give to the field ownership component of the fitness function. <code>0.2</code> <code>field_ownership_strategy</code> The strategy to use for field ownership differentiation. Can be <code>contrarian</code>, <code>leverage</code>, or <code>balanced</code>. <code>'contrarian'</code> <code>ownership_column</code> The name of the column in the player pool CSV that contains the ownership data. <code>'ownership'</code> <code>top_k_focus</code> The number of top lineups to prioritize in the score component. <code>min(10, target_lineups)</code>"},{"location":"optimize-reference/#example","title":"Example","text":"<pre><code>ctx = {\n    'ga_settings': {\n        'target_lineups': 20,\n        'score_weight': 0.5,\n        'diversity_weight': 0.3,\n        'field_ownership_weight': 0.2,\n        'field_ownership_strategy': 'contrarian',\n        'ownership_column': 'ownership',\n        'top_k_focus': 5,\n        # ... other GA settings\n    }\n}\n=======\n# Optimize Reference\n\nThe optimize module provides different optimization strategies for lineup generation.\n\n## Available Optimizers\n\n### OptimizeDefault\nThe standard single-lineup optimizer that uses a genetic algorithm to find the best possible lineup.\n\n**Use case**: When you need one optimal lineup.\n\n**Key features**:\n- Fast convergence to optimal solution\n- Proven genetic algorithm implementation\n- Suitable for most single-lineup scenarios\n\n### OptimizeMultilineup\nAdvanced optimizer for generating multiple diverse lineups using a post-processing approach.\n\n**Use case**: When you need multiple diverse lineups (50-150 lineups).\n\n**Key features**:\n- Quality-first approach: Runs standard GA first, then selects diverse lineups\n- Aggressive diversity selection with configurable thresholds\n- Scalable for large lineup sets\n- Comprehensive diversity metrics\n\n**Configuration parameters**:\n- `target_lineups`: Number of lineups to generate (default: 1)\n- `diversity_weight`: Weight for diversity vs quality (default: 0.2)\n- `min_overlap_threshold`: Minimum diversity requirement (default: 0.4)\n- `diversity_method`: 'jaccard' or 'hamming' similarity (default: 'jaccard')\n\n**Example usage**:\n```python\nfrom pangadfs.optimize import OptimizeMultilineup\n\n# Configure for multiple diverse lineups\nga_settings = {\n    'target_lineups': 100,\n    'diversity_weight': 0.25,\n    'min_overlap_threshold': 0.4,\n    'diversity_method': 'jaccard',\n    'population_size': 1000,\n    'n_generations': 150,\n    # ... other GA settings\n}\n\noptimizer = OptimizeMultilineup()\nga = GeneticAlgorithm(ctx={'ga_settings': ga_settings, ...}, optimize=optimizer)\nresults = ga.optimize()\n\n# Access multiple lineups\nlineups = results['lineups']  # List of DataFrames\nscores = results['scores']    # List of scores\ndiversity_metrics = results['diversity_metrics']  # Diversity statistics\n</code></pre>"},{"location":"optimize-reference/#removed-optimizers","title":"Removed Optimizers","text":"<p>The following optimizers have been removed to streamline the codebase:</p> <ul> <li><code>OptimizeMultilineupSets</code> - Replaced by OptimizeMultilineup's superior post-processing approach</li> <li><code>OptimizePoolBased</code> - Removed due to complexity without clear benefits</li> <li><code>OptimizeMultiObjective</code> - Removed as academic approach not suitable for practical use</li> </ul>"},{"location":"optimize-reference/#api-reference","title":"API Reference","text":""},{"location":"optimize-reference/#pangadfs.optimize","title":"<code>pangadfs.optimize</code>","text":""},{"location":"optimize-reference/#pangadfs.optimize.OptimizeDefault","title":"<code>OptimizeDefault()</code>","text":"<p>               Bases: <code>OptimizeBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"optimize-reference/#pangadfs.optimize.OptimizeDefault.optimize","title":"<code>optimize(ga, **kwargs)</code>","text":"<p>Creates initial pool</p> <p>Parameters:</p> Name Type Description Default <code>ga</code> <code>GeneticAlgorithm</code> <p>the ga instance</p> required <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict</p> <code>Dict[str, Any]</code> <p>'population': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'fitness': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'best_lineup': pd.DataFrame,</p> <code>Dict[str, Any]</code> <p>'best_score': float</p> Source code in <code>pangadfs/optimize.py</code> <pre><code>def optimize(self, ga: GeneticAlgorithm, **kwargs) -&gt; Dict[str, Any]:\n    \"\"\"Creates initial pool\n\n    Args:\n        ga (GeneticAlgorithm): the ga instance\n        **kwargs: keyword arguments for plugins\n\n    Returns:\n        Dict\n        'population': np.ndarray,\n        'fitness': np.ndarray,\n        'best_lineup': pd.DataFrame,\n        'best_score': float\n\n    \"\"\"\n    # Start profiling\n    ga.profiler.start_optimization()\n    # create pool and pospool\n    # pospool used to generate initial population\n    # is a dict of position_name: DataFrame\n    pop_size = ga.ctx['ga_settings']['population_size']\n    pool = ga.pool(csvpth=ga.ctx['ga_settings']['csvpth'])\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'position': ga.ctx['ga_settings']['position_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    posfilter = ga.ctx['site_settings']['posfilter']\n    flex_positions = ga.ctx['site_settings']['flex_positions']\n    pospool = ga.pospool(pool=pool, posfilter=posfilter, column_mapping=cmap, flex_positions=flex_positions)\n\n    # create salary and points arrays\n    # these match indices of pool\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    points = pool[cmap['points']].values\n    salaries = pool[cmap['salary']].values\n\n    # create initial population\n    initial_population = ga.populate(\n        pospool=pospool, \n        posmap=ga.ctx['site_settings']['posmap'], \n        population_size=pop_size\n    )\n\n    # apply validators\n    # default is to validate duplicates, salary, and positions\n    # can add other validators as desired\n    initial_population = ga.validate(\n        population=initial_population, \n        salaries=salaries,\n        salary_cap=ga.ctx['site_settings']['salary_cap'],\n        pool=pool,\n        posmap=ga.ctx['site_settings']['posmap'],\n        position_column=ga.ctx['ga_settings']['position_column'],\n        flex_positions=ga.ctx['site_settings']['flex_positions']\n    )\n\n    # need fitness to determine best lineup\n    # and also for selection when loop starts\n    population_fitness = ga.fitness(\n        population=initial_population, \n        points=points\n    )\n\n    # set overall_max based on initial population\n    omidx = population_fitness.argmax()\n    best_fitness = population_fitness[omidx]\n    best_lineup = initial_population[omidx]\n\n    # Mark setup phase complete\n    ga.profiler.mark_setup_complete()\n\n    # Mark initial best solution (generation 0)\n    ga.profiler.mark_best_solution(0)\n\n    # create new generations\n    n_unimproved = 0\n    population = initial_population.copy()\n\n    for i in range(1, ga.ctx['ga_settings']['n_generations'] + 1):\n        # Start generation timing\n        ga.profiler.start_generation(i)\n\n        # end program after n generations if not improving\n        if n_unimproved == ga.ctx['ga_settings']['stop_criteria']:\n            break\n\n        # display progress information with verbose parameter\n        if ga.ctx['ga_settings'].get('verbose'):\n            logging.info(f'Starting generation {i}')\n            logging.info(f'Best lineup score {best_fitness}')\n\n        # select the population\n        # here, we are holding back the fittest 20% to ensure\n        # that crossover and mutation do not overwrite good individuals\n        elite = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population) // ga.ctx['ga_settings'].get('elite_divisor', 5),\n            method=ga.ctx['ga_settings'].get('elite_method', 'fittest')\n        )\n\n        selected = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population),\n            method=ga.ctx['ga_settings'].get('select_method', 'roulette')\n        )\n\n        # cross over the population\n        # here, we use uniform crossover, which splits the population\n        # and randomly exchanges 0 - all chromosomes\n        crossed_over = ga.crossover(population=selected, method=ga.ctx['ga_settings'].get('crossover_method', 'uniform'))\n\n        # mutate the crossed over population (leave elite alone)\n        # can use fixed rate or variable to reduce mutation over generations\n        # here we use a variable rate that increases if no improvement is found\n        mutation_rate = ga.ctx['ga_settings'].get('mutation_rate', max(.05, n_unimproved / 50))\n        mutated = ga.mutate(population=crossed_over, mutation_rate=mutation_rate)\n\n        # validate the population (elite + mutated)\n        population = ga.validate(\n            population=np.vstack((elite, mutated)), \n            salaries=salaries, \n            salary_cap=ga.ctx['site_settings']['salary_cap'],\n            pool=pool,\n            posmap=ga.ctx['site_settings']['posmap'],\n            position_column=ga.ctx['ga_settings']['position_column'],\n            flex_positions=ga.ctx['site_settings']['flex_positions']\n        )\n\n        # assess fitness and get the best score\n        population_fitness = ga.fitness(population=population, points=points)\n        omidx = population_fitness.argmax()\n        generation_max = population_fitness[omidx]\n\n        # if new best score, then set n_unimproved to 0\n        # and save the new best score and lineup\n        # otherwise increment n_unimproved\n        if generation_max &gt; best_fitness:\n            logging.info(f'Lineup improved to {generation_max}')\n            best_fitness = generation_max\n            best_lineup = population[omidx]\n            n_unimproved = 0\n            # Mark when best solution was found\n            ga.profiler.mark_best_solution(i)\n        else:\n            n_unimproved += 1\n            logging.info(f'Lineup unimproved {n_unimproved} times')\n\n        # End generation timing\n        ga.profiler.end_generation()\n\n    # End profiling\n    ga.profiler.end_optimization()\n\n    # FINALIZE RESULTS\n    # will break after n_generations or when stop_criteria reached\n    results = {\n        'population': population,\n        'fitness': population_fitness,\n        'best_lineup': pool.loc[best_lineup, :],\n        'best_score': best_fitness\n    }\n\n    # Add profiling data to results\n    if ga.profiler.enabled:\n        results['profiling'] = ga.profiler.export_to_dict()\n\n    return results\n</code></pre>"},{"location":"optimize-reference/#pangadfs.optimize.OptimizeMultilineup","title":"<code>OptimizeMultilineup()</code>","text":"<p>               Bases: <code>OptimizeBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"optimize-reference/#pangadfs.optimize.OptimizeMultilineup.optimize","title":"<code>optimize(ga, **kwargs)</code>","text":"<p>Optimizes for multiple diverse lineups</p> <p>Parameters:</p> Name Type Description Default <code>ga</code> <code>GeneticAlgorithm</code> <p>the ga instance</p> required <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing:</p> <code>Dict[str, Any]</code> <p>'population': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'fitness': np.ndarray,</p> <code>Dict[str, Any]</code> <p>'best_lineup': pd.DataFrame,  # For backward compatibility</p> <code>Dict[str, Any]</code> <p>'best_score': float,          # For backward compatibility</p> <code>Dict[str, Any]</code> <p>'lineups': List[pd.DataFrame], # Multiple lineups</p> <code>Dict[str, Any]</code> <p>'scores': List[float],        # Corresponding scores</p> <code>Dict[str, Any]</code> <p>'diversity_metrics': Dict     # Diversity statistics</p> Source code in <code>pangadfs/optimize.py</code> <pre><code>def optimize(self, ga: GeneticAlgorithm, **kwargs) -&gt; Dict[str, Any]:\n    \"\"\"Optimizes for multiple diverse lineups\n\n    Args:\n        ga (GeneticAlgorithm): the ga instance\n        **kwargs: keyword arguments for plugins\n\n    Returns:\n        Dict containing:\n        'population': np.ndarray,\n        'fitness': np.ndarray,\n        'best_lineup': pd.DataFrame,  # For backward compatibility\n        'best_score': float,          # For backward compatibility\n        'lineups': List[pd.DataFrame], # Multiple lineups\n        'scores': List[float],        # Corresponding scores\n        'diversity_metrics': Dict     # Diversity statistics\n\n    \"\"\"\n    # Get multilineup settings with defaults\n    target_lineups = ga.ctx['ga_settings'].get('target_lineups', 1)\n    diversity_weight = ga.ctx['ga_settings'].get('diversity_weight', 0.2)\n    min_overlap_threshold = ga.ctx['ga_settings'].get('min_overlap_threshold', 0.4)  # More aggressive default\n    diversity_method = ga.ctx['ga_settings'].get('diversity_method', 'jaccard')\n\n    # Start profiling\n    ga.profiler.start_optimization()\n\n    # Create pool and pospool (same as OptimizeDefault)\n    pop_size = ga.ctx['ga_settings']['population_size']\n    pool = ga.pool(csvpth=ga.ctx['ga_settings']['csvpth'])\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'position': ga.ctx['ga_settings']['position_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    posfilter = ga.ctx['site_settings']['posfilter']\n    flex_positions = ga.ctx['site_settings']['flex_positions']\n    pospool = ga.pospool(pool=pool, posfilter=posfilter, column_mapping=cmap, flex_positions=flex_positions)\n\n    # Create salary and points arrays\n    cmap = {'points': ga.ctx['ga_settings']['points_column'],\n            'salary': ga.ctx['ga_settings']['salary_column']}\n    points = pool[cmap['points']].values\n    salaries = pool[cmap['salary']].values\n\n    # Create initial population\n    initial_population = ga.populate(\n        pospool=pospool, \n        posmap=ga.ctx['site_settings']['posmap'], \n        population_size=pop_size\n    )\n\n    # Apply validators\n    initial_population = ga.validate(\n        population=initial_population, \n        salaries=salaries,\n        salary_cap=ga.ctx['site_settings']['salary_cap'],\n        pool=pool,\n        posmap=ga.ctx['site_settings']['posmap'],\n        position_column=ga.ctx['ga_settings']['position_column'],\n        flex_positions=ga.ctx['site_settings']['flex_positions']\n    )\n\n    # Calculate fitness\n    population_fitness = ga.fitness(\n        population=initial_population, \n        points=points\n    )\n\n    # Set overall_max based on initial population\n    omidx = population_fitness.argmax()\n    best_fitness = population_fitness[omidx]\n    best_lineup = initial_population[omidx]\n\n    # Mark setup phase complete\n    ga.profiler.mark_setup_complete()\n\n    # Mark initial best solution (generation 0)\n    ga.profiler.mark_best_solution(0)\n\n    # Create new generations (same GA loop as OptimizeDefault)\n    n_unimproved = 0\n    population = initial_population.copy()\n\n    for i in range(1, ga.ctx['ga_settings']['n_generations'] + 1):\n        # Start generation timing\n        ga.profiler.start_generation(i)\n\n        # End program after n generations if not improving\n        if n_unimproved == ga.ctx['ga_settings']['stop_criteria']:\n            break\n\n        # Display progress information with verbose parameter\n        if ga.ctx['ga_settings'].get('verbose'):\n            logging.info(f'Starting generation {i}')\n            logging.info(f'Best lineup score {best_fitness}')\n\n        # Select the population\n        elite = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population) // ga.ctx['ga_settings'].get('elite_divisor', 5),\n            method=ga.ctx['ga_settings'].get('elite_method', 'fittest')\n        )\n\n        selected = ga.select(\n            population=population, \n            population_fitness=population_fitness, \n            n=len(population),\n            method=ga.ctx['ga_settings'].get('select_method', 'roulette')\n        )\n\n        # Cross over the population\n        crossed_over = ga.crossover(population=selected, method=ga.ctx['ga_settings'].get('crossover_method', 'uniform'))\n\n        # Mutate the crossed over population\n        mutation_rate = ga.ctx['ga_settings'].get('mutation_rate', max(.05, n_unimproved / 50))\n        mutated = ga.mutate(population=crossed_over, mutation_rate=mutation_rate)\n\n        # Validate the population\n        population = ga.validate(\n            population=np.vstack((elite, mutated)), \n            salaries=salaries, \n            salary_cap=ga.ctx['site_settings']['salary_cap'],\n            pool=pool,\n            posmap=ga.ctx['site_settings']['posmap'],\n            position_column=ga.ctx['ga_settings']['position_column'],\n            flex_positions=ga.ctx['site_settings']['flex_positions']\n        )\n\n        # Assess fitness and get the best score\n        population_fitness = ga.fitness(population=population, points=points)\n        omidx = population_fitness.argmax()\n        generation_max = population_fitness[omidx]\n\n        # If new best score, then set n_unimproved to 0\n        if generation_max &gt; best_fitness:\n            logging.info(f'Lineup improved to {generation_max}')\n            best_fitness = generation_max\n            best_lineup = population[omidx]\n            n_unimproved = 0\n            # Mark when best solution was found\n            ga.profiler.mark_best_solution(i)\n        else:\n            n_unimproved += 1\n            logging.info(f'Lineup unimproved {n_unimproved} times')\n\n        # End generation timing\n        ga.profiler.end_generation()\n\n    # End profiling\n    ga.profiler.end_optimization()\n\n    # MULTILINEUP SELECTION\n    # Select diverse lineups from final population\n    if target_lineups == 1:\n        # Single lineup mode - return same structure as OptimizeDefault\n        selected_lineups = [population[omidx]]\n        selected_scores = [best_fitness]\n        diversity_metrics = {'avg_overlap': 0.0, 'min_overlap': 0.0, 'diversity_matrix': np.array([[1.0]])}\n    else:\n        # Multiple lineup mode - select diverse lineups\n        selected_lineups, selected_scores, diversity_metrics = self._select_diverse_lineups(\n            population, population_fitness, target_lineups, diversity_weight, min_overlap_threshold, diversity_method\n        )\n\n    # FINALIZE RESULTS\n    results = {\n        'population': population,\n        'fitness': population_fitness,\n        'best_lineup': pool.loc[best_lineup, :],  # Backward compatibility\n        'best_score': best_fitness,               # Backward compatibility\n        'lineups': [pool.loc[lineup, :] for lineup in selected_lineups],\n        'scores': selected_scores,\n        'diversity_metrics': diversity_metrics\n    }\n\n    # Add profiling data to results\n    if ga.profiler.enabled:\n        results['profiling'] = ga.profiler.export_to_dict()\n\n    return results\n</code></pre>"},{"location":"penalty-reference/","title":"Penalty","text":""},{"location":"penalty-reference/#pangadfs.penalty","title":"<code>pangadfs.penalty</code>","text":""},{"location":"penalty-reference/#pangadfs.penalty--penalty-framework","title":"Penalty framework","text":"<p>Idea is to replace optimizer rules with penalties. Penalties can be negative (bad) or positive (good). * Advantages      * Doesn't throw away reasonable options (125% ownership arbitrary) and is flexible.     * Does not require absurdly complex optimizer rules.     * Can easily layer penalties on top of each other. * Disadvantages     * Takes some fiddling to get the parameters correct.</p>"},{"location":"penalty-reference/#pangadfs.penalty--possible-penalties","title":"Possible penalties","text":"<ul> <li>Individual ownership penalty (global or just high-owned)</li> <li>Cumulative ownership penalty (global or just high-owned)</li> <li>Distances (too many similar lineups)</li> <li>Diversity (another way of measuring too many similar lineups)</li> <li>Position combinations (QB vs DST, WR + own DST, etc.)</li> </ul>"},{"location":"penalty-reference/#pangadfs.penalty.DistancePenalty","title":"<code>DistancePenalty()</code>","text":"<p>               Bases: <code>PenaltyBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.DistancePenalty.penalty","title":"<code>penalty(*, population)</code>","text":"<p>Calculates distance penalty for overlapping lineups</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D array of float</p> add parameters for positional weighting <p>that is, can prioritize distance at WR or other position conversely, can deprioritize distance at RB or other position</p> Source code in <code>pangadfs/penalty.py</code> <pre><code>def penalty(self, *, population: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Calculates distance penalty for overlapping lineups\n\n    Args:\n        population (np.ndarray): the population\n\n    Returns:\n        np.ndarray: 1D array of float\n\n    TODO: add parameters for positional weighting\n          that is, can prioritize distance at WR or other position\n          conversely, can deprioritize distance at RB or other position\n    \"\"\"\n    # one-hot encoded population\n    # so, assume pool has ids 0, 1, 2, 3, 4\n    # lineup is 1, 2\n    # ohe would be [0, 1, 1, 0, 0] for that lineup\n    ohe = np.sum((np.arange(population.max()) == population[...,None]-1).astype(int), axis=1)\n\n    # now calculate distance between individuals in population\n    # dist is a square matrix same length as population\n    b = ohe.reshape(ohe.shape[0], 1, ohe.shape[1])\n    dist = np.sqrt(np.einsum('ijk, ijk-&gt;ij', ohe-b, ohe-b))\n    return 0 - ((dist - dist.mean()) / dist.std())\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.DiversityPenalty","title":"<code>DiversityPenalty()</code>","text":"<p>               Bases: <code>PenaltyBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.DiversityPenalty.penalty","title":"<code>penalty(*, population)</code>","text":"<p>Calculates diversity penalty for overlapping lineups</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D array of float</p> Source code in <code>pangadfs/penalty.py</code> <pre><code>def penalty(self, *, population: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Calculates diversity penalty for overlapping lineups\n\n    Args:\n        population (np.ndarray): the population\n\n    Returns:\n        np.ndarray: 1D array of float\n\n    \"\"\"\n    uniques = np.unique(population)\n    a = (population[..., None] == uniques).sum(1)\n    out = np.einsum('ij,kj-&gt;ik', a, a)\n    diversity = np.sum(out, axis=1) / population.size\n    return 0 - ((diversity - diversity.mean()) / diversity.std())\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.HighOwnershipPenalty","title":"<code>HighOwnershipPenalty()</code>","text":"<p>               Bases: <code>PenaltyBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.HighOwnershipPenalty.penalty","title":"<code>penalty(*, ownership, base=3, boost=2)</code>","text":"<p>Calculates penalties that are inverse to projected ownership</p> <p>Parameters:</p> Name Type Description Default <code>ownership</code> <code>ndarray</code> <p>1D array of ownership</p> required <code>base</code> <code>int</code> <p>the logarithm base, default 3</p> <code>3</code> <code>boost</code> <code>int</code> <p>the constant to boost low-owned players</p> <code>2</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D array of penalties</p> <p>TODO: implement this method</p> Source code in <code>pangadfs/penalty.py</code> <pre><code>def penalty(self, *, ownership: np.ndarray, base: float =3, boost: float = 2) -&gt; np.ndarray:\n    \"\"\"Calculates penalties that are inverse to projected ownership\n\n    Args:\n        ownership (np.ndarray): 1D array of ownership\n        base (int): the logarithm base, default 3\n        boost (int): the constant to boost low-owned players\n\n    Returns:\n        np.ndarray: 1D array of penalties\n\n    TODO: implement this method\n    \"\"\"\n    pass\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.OwnershipPenalty","title":"<code>OwnershipPenalty()</code>","text":"<p>               Bases: <code>PenaltyBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"penalty-reference/#pangadfs.penalty.OwnershipPenalty.penalty","title":"<code>penalty(*, ownership, base=3, boost=2)</code>","text":"<p>Calculates penalties that are inverse to projected ownership</p> <p>Parameters:</p> Name Type Description Default <code>ownership</code> <code>ndarray</code> <p>1D array of ownership</p> required <code>base</code> <code>int</code> <p>the logarithm base, default 3</p> <code>3</code> <code>boost</code> <code>int</code> <p>the constant to boost low-owned players</p> <code>2</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D array of penalties</p> Source code in <code>pangadfs/penalty.py</code> <pre><code>def penalty(self, *, ownership: np.ndarray, base: float =3, boost: float = 2) -&gt; np.ndarray:\n    \"\"\"Calculates penalties that are inverse to projected ownership\n\n    Args:\n        ownership (np.ndarray): 1D array of ownership\n        base (int): the logarithm base, default 3\n        boost (int): the constant to boost low-owned players\n\n    Returns:\n        np.ndarray: 1D array of penalties\n\n    \"\"\"\n    return 0 - np.log(ownership) / np.log(base) + boost\n</code></pre>"},{"location":"plugin-namespaces/","title":"Plugin Namespaces","text":"<p>The plugin namespaces are specified using the entry_points section in the setup.py file. Currently, there are entry points for pool, pospool, populate, fitness, crossover, mutate, and validate.</p> <p>Pangadfs installs default plugins for each namespace. Other plugins can be installed and loaded by the application.</p>"},{"location":"plugin-namespaces/#pool","title":"pool","text":"<p>Pool plugins create a dataframe that must contain, at a minimum, columns for position (str), salary (int), and points (float) with no missing values. It can have as many other columns as desired.</p> <p>The index must be unique. DefaultPool uses an RangeIndex, which works well, but a specific index type is not required. </p>"},{"location":"plugin-namespaces/#pospool","title":"pospool","text":"<p>Pospool plugins create a dict. The keys are positions ('QB', 'WR', etc.). The values are dataframes of all of the players that are eligible for the position. DefaultPospool maintains the index from DefaultPool and has columns for salary (int), points (float), and prob (float). Prob is the normalized probability of points per dollar, defined as (points / salary * 1000) / sum of points per dollar.</p> <p>There is no requirment to use weighted probabilities but it is highly advisable. The genetic algorithm will converge on the optimal solution quicker when the initial population is fitter. </p>"},{"location":"plugin-namespaces/#populate","title":"populate","text":"<p>Populate plugins create the initial population of lineups from the pospool. DefaultPopulate creates an ndarray of indices to rows in the pool. Each row in the 2D array has lineup_size elemens (indices for each player in a lineup, 9 for DK). The number of rows is set by the intial_size parameter.</p>"},{"location":"plugin-namespaces/#fitness","title":"fitness","text":"<p>Fitness plugins Creates 1D array of fitness scores. Right now, can only run fitness once but can use any function to generate single value.</p>"},{"location":"plugin-namespaces/#crossover","title":"crossover","text":"<p>Generates new population from the initial population. Can run multiple crossover plugins If pass agg=True, will aggregate the results into one population. Otherwise, runs on crossed-over population</p>"},{"location":"plugin-namespaces/#mutate","title":"mutate","text":"<p>Generates new population from the initial population. Can run multiple mutate plugins If pass agg=True, will aggregate the results into one population. Otherwise, second call runs on first mutated population, and so forth       </p>"},{"location":"plugin-namespaces/#validate","title":"validate","text":"<p>Generates new population from the initial population. Can run multiple validate plugins Each subsequent call runs on prior validated population</p>"},{"location":"pool-reference/","title":"Pool","text":""},{"location":"pool-reference/#pangadfs.pool","title":"<code>pangadfs.pool</code>","text":""},{"location":"pool-reference/#pangadfs.pool.PoolDefault","title":"<code>PoolDefault()</code>","text":"<p>               Bases: <code>PoolBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"pool-reference/#pangadfs.pool.PoolDefault.pool","title":"<code>pool(*, csvpth, thresh=4, **kwargs)</code>","text":"<p>Creates initial pool</p> <p>Parameters:</p> Name Type Description Default <code>csvpth</code> <code>Path</code> <p>path for csv file</p> required <code>thresh</code> <code>int</code> <p>global filter on low-scoring players</p> <code>4</code> <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns:</p> <code>DataFrame</code> <p>player, team, pos, salary, proj</p> Source code in <code>pangadfs/pool.py</code> <pre><code>def pool(self, \n         *, \n         csvpth: Path,\n         thresh: int = 4,\n         **kwargs\n         ) -&gt; pd.DataFrame:\n    \"\"\"Creates initial pool\n\n    Args:\n        csvpth (Path): path for csv file\n        thresh (int): global filter on low-scoring players\n        **kwargs: keyword arguments for plugins\n\n    Returns:\n        DataFrame with columns:\n        player, team, pos, salary, proj\n\n    \"\"\"\n    df = pd.read_csv(csvpth)\n    assert set(['player', 'team', 'pos', 'salary', 'proj']).issubset(df.columns)\n    df = df.loc[df.proj &gt;= thresh, :]\n    return df.sort_values(['pos']).reset_index(drop=True)\n</code></pre>"},{"location":"populate-reference/","title":"Population","text":""},{"location":"populate-reference/#pangadfs.populate","title":"<code>pangadfs.populate</code>","text":""},{"location":"populate-reference/#pangadfs.populate.PopulateDefault","title":"<code>PopulateDefault()</code>","text":"<p>               Bases: <code>PopulateBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"populate-reference/#pangadfs.populate.PopulateDefault.populate","title":"<code>populate(*, pospool, posmap, population_size, probcol='prob', **kwargs)</code>","text":"<p>Creates individuals in population</p> <p>Parameters:</p> Name Type Description Default <code>pospool</code> <code>Dict[str, DataFrame]</code> <p>pool split into positions</p> required <code>posmap</code> <code>Dict[str, int]</code> <p>positions &amp; accompanying roster slots</p> required <code>population_size</code> <code>int</code> <p>number of individuals to create</p> required <code>probcol</code> <code>str</code> <p>the dataframe column with probabilities</p> <code>'prob'</code> <code>**kwargs</code> <p>keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>ndarray of size (population_size, sum(posmap.values()))</p> Source code in <code>pangadfs/populate.py</code> <pre><code>def populate(self,\n             *, \n             pospool, \n             posmap: Dict[str, int], \n             population_size: int, \n             probcol: str='prob',\n             **kwargs) -&gt; np.ndarray:\n    \"\"\"Creates individuals in population\n\n    Args:\n        pospool (Dict[str, DataFrame]): pool split into positions\n        posmap (Dict[str, int]): positions &amp; accompanying roster slots\n        population_size (int): number of individuals to create\n        probcol (str): the dataframe column with probabilities\n        **kwargs: keyword arguments\n\n    Returns:\n        ndarray of size (population_size, sum(posmap.values()))\n\n    \"\"\"\n    pos_samples = {\n        pos: multidimensional_shifting(pospool[pos].index, population_size, n, pospool[pos][probcol])\n        for pos, n in posmap.items()\n    }\n\n    # Handle FLEX separately to maintain original behavior\n    if 'FLEX' in posmap:\n        # concatenate non-FLEX positions into single row\n        non_flex_samples = [pos_samples[pos] for pos in posmap if pos != 'FLEX']\n        if non_flex_samples:\n            pop = np.concatenate(non_flex_samples, axis=1)\n        else:\n            pop = np.empty((population_size, 0), dtype=int)\n\n        # For FLEX, take the correct number of positions as specified in posmap\n        flex_count = posmap['FLEX']\n        flex_sample = pos_samples['FLEX'][:, :flex_count]  # Take correct number of FLEX positions\n\n        return np.column_stack((pop, flex_sample))\n    else:\n        # No FLEX position, concatenate all\n        return np.concatenate([pos_samples[pos] for pos in posmap], axis=1)\n</code></pre>"},{"location":"pospool-reference/","title":"Position Pool","text":""},{"location":"pospool-reference/#pangadfs.pospool","title":"<code>pangadfs.pospool</code>","text":""},{"location":"pospool-reference/#pangadfs.pospool.PospoolDefault","title":"<code>PospoolDefault()</code>","text":"<p>               Bases: <code>PospoolBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"pospool-reference/#pangadfs.pospool.PospoolDefault.pospool","title":"<code>pospool(*, pool, posfilter, column_mapping, flex_positions=('RB', 'WR', 'TE'), **kwargs)</code>","text":"<p>Creates initial position pool</p> <p>Parameters:</p> Name Type Description Default <code>pool</code> <code>DataFrame</code> required <code>posfilter</code> <code>Dict[str, int]</code> <p>filter out low scorers by position</p> required <code>column_mapping</code> <code>Dict[str, str]</code> <p>column names for player, position, salary, projection</p> required <code>flex_positions</code> <code>Iterable[str]</code> <p>e.g. (WR, RB, TE)</p> <code>('RB', 'WR', 'TE')</code> <code>**kwargs</code> <p>Keyword arguments for plugins (other than default)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, DataFrame]</code> <p>Dict[str, pd.DataFrame] where keys == posfilter.keys</p> Source code in <code>pangadfs/pospool.py</code> <pre><code>def pospool(self,\n            *,\n            pool: pd.DataFrame,\n            posfilter: Dict[str, int],\n            column_mapping: Dict[str, str],\n            flex_positions: Iterable[str] = ('RB', 'WR', 'TE'),\n            **kwargs\n            ) -&gt; Dict[str, pd.DataFrame]:\n    \"\"\"Creates initial position pool\n\n    Args:\n        pool (pd.DataFrame):\n        posfilter (Dict[str, int]): filter out low scorers by position\n        column_mapping (Dict[str, str]): column names for player, position, salary, projection\n        flex_positions (Iterable[str]): e.g. (WR, RB, TE)\n        **kwargs: Keyword arguments for plugins (other than default)\n\n    Returns:\n        Dict[str, pd.DataFrame] where keys == posfilter.keys\n\n    \"\"\"\n    d = {}\n    poscol = column_mapping.get('position', 'pos')\n    pointscol = column_mapping.get('points', 'proj')\n    salcol = column_mapping.get('salary', 'salary')\n    for position, thresh in posfilter.items():\n        if position == 'FLEX':\n            tmp = pool.loc[(pool[poscol].isin(flex_positions)) &amp; (pool[pointscol] &gt;= thresh), [pointscol, salcol]]      \n        else:           \n            tmp = pool.loc[(pool[poscol] == position) &amp; (pool[pointscol] &gt;= thresh), [pointscol, salcol]]\n        prob_ = (tmp[pointscol] / tmp[salcol]) * 1000\n        prob_ = prob_ / prob_.sum()\n        d[position] = tmp.assign(prob=prob_)\n    return d\n</code></pre>"},{"location":"profiling/","title":"Genetic Algorithm Profiling","text":"<p>The pangadfs genetic algorithm now includes comprehensive profiling capabilities to help you analyze performance and identify optimization bottlenecks.</p>"},{"location":"profiling/#overview","title":"Overview","text":"<p>The profiling system tracks timing for each component of the genetic algorithm and provides detailed performance analysis including:</p> <ul> <li>Component-level timing: Individual timing for each GA operation (selection, crossover, mutation, etc.)</li> <li>Generation-level metrics: Per-generation timing and convergence tracking</li> <li>Convergence analysis: When the optimal solution was found during the optimization process</li> <li>Performance insights: Automatic analysis of time distribution and bottlenecks</li> </ul>"},{"location":"profiling/#enabling-profiling","title":"Enabling Profiling","text":"<p>To enable profiling, simply add <code>'enable_profiling': True</code> to your GA settings:</p> <pre><code>ctx = {\n    'ga_settings': {\n        'crossover_method': 'uniform',\n        'csvpth': Path('data/pool.csv'),\n        'n_generations': 20,\n        'population_size': 30000,\n        'enable_profiling': True,  # Enable profiling\n        # ... other settings\n    },\n    # ... site settings\n}\n</code></pre>"},{"location":"profiling/#using-profiling","title":"Using Profiling","text":""},{"location":"profiling/#basic-usage","title":"Basic Usage","text":"<pre><code>from pangadfs.ga import GeneticAlgorithm\n\n# Create GA instance with profiling enabled\nga = GeneticAlgorithm(ctx=ctx, driver_managers=dmgrs, extension_managers=emgrs)\n\n# Run optimization\nresults = ga.optimize()\n\n# Display results\nprint(results['best_lineup'])\nprint(f'Lineup score: {results[\"best_score\"]}')\n\n# Display profiling results\nif ga.profiler.enabled:\n    ga.profiler.print_profiling_results()\n</code></pre>"},{"location":"profiling/#programmatic-access","title":"Programmatic Access","text":"<p>You can also access profiling data programmatically:</p> <pre><code># Run optimization\nresults = ga.optimize()\n\n# Access profiling data from results\nif 'profiling' in results:\n    profiling_data = results['profiling']\n\n    print(f\"Total optimization time: {profiling_data['total_time']:.2f}s\")\n    print(f\"Time to best solution: {profiling_data['time_to_best_solution']:.2f}s\")\n    print(f\"Best solution found at generation: {profiling_data['best_solution_generation']}\")\n\n    # Access individual operation timings\n    for op_name, op_data in profiling_data['operations'].items():\n        print(f\"{op_name}: {op_data['total_time']:.3f}s ({op_data['call_count']} calls)\")\n</code></pre>"},{"location":"profiling/#profiling-output","title":"Profiling Output","text":"<p>When profiling is enabled, you'll see detailed output like this:</p> <pre><code>============================================================\nGENETIC ALGORITHM PROFILING RESULTS\n============================================================\n\nTotal Optimization Time: 45.23 seconds\nSetup Time: 3.45 seconds\nOptimization Loop Time: 41.78 seconds\nTime to Best Solution: 32.18 seconds (Generation 15)\nBest Solution Found at: 71.2% of total runtime\nGenerations Completed: 20\nAverage Generation Time: 2.089 seconds\n\nComponent Timing Summary:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Operation           \u2502 Total (s) \u2502 Avg (s) \u2502 Min (s) \u2502 Max (s) \u2502 Calls     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Fitness Evaluation  \u2502     18.45 \u2502   0.878 \u2502   0.820 \u2502   1.020 \u2502        21 \u2502\n\u2502 Selection           \u2502      8.92 \u2502   0.213 \u2502   0.190 \u2502   0.250 \u2502        42 \u2502\n\u2502 Crossover           \u2502      6.78 \u2502   0.339 \u2502   0.310 \u2502   0.380 \u2502        20 \u2502\n\u2502 Mutation            \u2502      3.12 \u2502   0.156 \u2502   0.140 \u2502   0.190 \u2502        20 \u2502\n\u2502 Pool Creation       \u2502      2.45 \u2502   2.450 \u2502   2.450 \u2502   2.450 \u2502         1 \u2502\n\u2502 Validation          \u2502      1.41 \u2502   0.067 \u2502   0.060 \u2502   0.090 \u2502        21 \u2502\n\u2502 Initial Population  \u2502      3.21 \u2502   3.210 \u2502   3.210 \u2502   3.210 \u2502         1 \u2502\n\u2502 Pospool             \u2502      0.89 \u2502   0.890 \u2502   0.890 \u2502   0.890 \u2502         1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPerformance Insights:\n\u2022 Fitness Evaluation consumed 40.8% of component time\n\u2022 Selection consumed 19.7% of component time\n\u2022 Best solution found at 71.2% of total runtime\n\u2022 Fastest generation: 1.890s, Slowest: 2.340s\n============================================================\n</code></pre>"},{"location":"profiling/#profiling-data-structure","title":"Profiling Data Structure","text":"<p>The profiling data returned in results contains:</p> <pre><code>{\n    'profiling_enabled': True,\n    'total_time': 45.23,                    # Total optimization time\n    'setup_time': 3.45,                     # Time for setup phase\n    'optimization_time': 41.78,             # Time for optimization loop\n    'time_to_best_solution': 32.18,         # Time when best solution found\n    'best_solution_generation': 15,         # Generation when best found\n    'generations_completed': 20,            # Total generations completed\n    'avg_generation_time': 2.089,           # Average time per generation\n    'generation_times': [2.1, 2.0, ...],   # Individual generation times\n    'operations': {\n        'Pool Creation': {\n            'total_time': 2.45,\n            'call_count': 1,\n            'avg_time': 2.45,\n            'min_time': 2.45,\n            'max_time': 2.45,\n            'times': [2.45]\n        },\n        # ... other operations\n    }\n}\n</code></pre>"},{"location":"profiling/#performance-analysis","title":"Performance Analysis","text":"<p>The profiling system helps you identify:</p> <ol> <li>Bottleneck Operations: Which GA components take the most time</li> <li>Convergence Efficiency: How quickly the algorithm finds good solutions</li> <li>Generation Consistency: Whether generation times are stable</li> <li>Setup vs Optimization: Time distribution between setup and optimization phases</li> </ol>"},{"location":"profiling/#disabling-profiling","title":"Disabling Profiling","text":"<p>Profiling is disabled by default. To explicitly disable it:</p> <pre><code>ctx = {\n    'ga_settings': {\n        'enable_profiling': False,  # Explicitly disable\n        # ... other settings\n    }\n}\n</code></pre> <p>When disabled, profiling has zero performance overhead.</p>"},{"location":"profiling/#best-practices","title":"Best Practices","text":"<ol> <li>Enable for Development: Use profiling during development to understand performance characteristics</li> <li>Disable for Production: Disable profiling in production environments for maximum performance</li> <li>Analyze Bottlenecks: Focus optimization efforts on the most time-consuming operations</li> <li>Track Convergence: Use time-to-best-solution metrics to evaluate algorithm efficiency</li> <li>Compare Configurations: Use profiling to compare different GA parameter settings</li> </ol>"},{"location":"profiling/#example-use-cases","title":"Example Use Cases","text":""},{"location":"profiling/#finding-optimal-population-size","title":"Finding Optimal Population Size","text":"<pre><code># Test different population sizes and compare setup vs optimization time\nfor pop_size in [1000, 5000, 10000, 30000]:\n    ctx['ga_settings']['population_size'] = pop_size\n    ctx['ga_settings']['enable_profiling'] = True\n\n    ga = GeneticAlgorithm(ctx=ctx, ...)\n    results = ga.optimize()\n\n    profiling = results['profiling']\n    print(f\"Pop {pop_size}: Setup {profiling['setup_time']:.2f}s, \"\n          f\"Optimization {profiling['optimization_time']:.2f}s\")\n</code></pre>"},{"location":"profiling/#comparing-selection-methods","title":"Comparing Selection Methods","text":"<pre><code># Compare performance of different selection methods\nfor method in ['fittest', 'roulette', 'tournament']:\n    ctx['ga_settings']['select_method'] = method\n    ctx['ga_settings']['enable_profiling'] = True\n\n    ga = GeneticAlgorithm(ctx=ctx, ...)\n    results = ga.optimize()\n\n    selection_time = results['profiling']['operations']['Selection']['total_time']\n    print(f\"{method}: {selection_time:.3f}s total selection time\")\n</code></pre> <p>The profiling system provides comprehensive insights into your genetic algorithm's performance, helping you optimize both the algorithm parameters and the underlying implementation.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#030-upcoming","title":"0.3.0 (Upcoming)","text":"<p>Major Refactoring:</p> <ul> <li>Multilineup Optimization Streamlined: Removed inferior multilineup approaches and focused on the proven <code>OptimizeMultilineup</code> post-processing method</li> <li>Removed <code>OptimizeMultilineupSets</code>, <code>OptimizePoolBased</code>, and <code>OptimizeMultiObjective</code> classes</li> <li>Enhanced <code>OptimizeMultilineup</code> with aggressive diversity selection for better quality/diversity balance</li> <li>Simplified configuration with fewer parameters to tune</li> <li> <p>~50% reduction in multilineup-related code complexity</p> </li> <li> <p>Validation Module Consolidated: Merged position validation functionality into main validate module</p> </li> <li>Moved <code>PositionValidate</code> and <code>PositionValidateOptimized</code> from <code>validate_positions.py</code> to <code>validate.py</code></li> <li>Removed <code>validate_positions.py</code> file</li> <li>All validation classes now available from single <code>pangadfs.validate</code> import</li> <li>Improved code organization and developer experience</li> </ul> <p>Performance Improvements:</p> <ul> <li>Optimized Multilineup Selection: Enhanced diversity algorithm with progressive threshold relaxation</li> <li>Streamlined Codebase: Removed unused optimization approaches reducing overhead</li> <li>Better Memory Usage: Simplified algorithms use less memory for large lineup sets</li> </ul> <p>API Changes:</p> <ul> <li>Simplified Imports: All validation classes now imported from <code>pangadfs.validate</code></li> <li>Enhanced OptimizeMultilineup: New parameters for better diversity control</li> <li><code>min_overlap_threshold</code>: More aggressive diversity requirements (default: 0.4)</li> <li>Improved diversity metrics and reporting</li> <li>Removed Classes: <code>OptimizeMultilineupSets</code>, <code>OptimizePoolBased</code>, <code>OptimizeMultiObjective</code> no longer available</li> </ul> <p>Documentation Updates:</p> <ul> <li>Updated README.md with multilineup optimization examples</li> <li>Enhanced optimize-reference.md with detailed OptimizeMultilineup documentation</li> <li>Updated validate-reference.md to reflect module consolidation</li> <li>Added migration notes for validation imports</li> </ul> <p>Breaking Changes:</p> <ul> <li><code>OptimizeMultilineupSets</code>, <code>OptimizePoolBased</code>, and <code>OptimizeMultiObjective</code> classes removed</li> <li><code>pangadfs.validate_positions</code> module removed - use <code>pangadfs.validate</code> instead</li> <li>Some multilineup configuration parameters changed for better defaults</li> </ul> <p>Migration Guide:</p> <pre><code># Old validation imports (no longer work)\nfrom pangadfs.validate_positions import PositionValidate\n\n# New validation imports\nfrom pangadfs.validate import PositionValidate\n\n# Old multilineup optimization (no longer available)\nfrom pangadfs.optimize import OptimizeMultilineupSets\n\n# New multilineup optimization (recommended)\nfrom pangadfs.optimize import OptimizeMultilineup\n</code></pre>"},{"location":"release-notes/#020","title":"0.2.0","text":"<p>Major Changes:</p> <ul> <li>GUI Separation: The GUI application has been moved to a separate repository (pangadfs-gui) for better modularity and maintenance</li> <li>Reduced Dependencies: Core library now has minimal dependencies, with GUI-specific dependencies moved to the separate package</li> <li>Focused Core: The main pangadfs package now focuses purely on the genetic algorithm optimization engine</li> </ul> <p>Breaking Changes:</p> <ul> <li>Removed <code>pangadfs-gui</code> console command from core package</li> <li>Removed GUI-related dependencies from core requirements</li> <li>GUI functionality now requires separate installation: <code>pip install pangadfs-gui</code></li> </ul> <p>Installation Changes:</p> <ul> <li>Core library: <code>pip install pangadfs</code></li> <li>GUI application: <code>pip install pangadfs-gui</code> (requires core library)</li> </ul>"},{"location":"release-notes/#011","title":"0.1.1","text":"<p>Updated documentation structure</p>"},{"location":"release-notes/#010","title":"0.1.0","text":"<ul> <li>Feature Description</li> </ul> <p>Working version of basic application</p>"},{"location":"select-reference/","title":"Selection","text":""},{"location":"select-reference/#pangadfs.select","title":"<code>pangadfs.select</code>","text":""},{"location":"select-reference/#pangadfs.select.SelectDefault","title":"<code>SelectDefault()</code>","text":"<p>               Bases: <code>SelectBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"select-reference/#pangadfs.select.SelectDefault.select","title":"<code>select(*, population, population_fitness, n, method='roulette', **kwargs)</code>","text":"<p>Select individuals in population using specified method.</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population to mutate. Shape is n_individuals x n_chromosomes.</p> required <code>population_fitness</code> <code>ndarray</code> <p>the population fitness. Is a 1D array same length as population.</p> required <code>n</code> <code>int</code> <p>total number of individuals to select</p> required <code>method</code> <code>str</code> <p>'roulette', 'su', 'scaled'; default 'roulette'</p> <code>'roulette'</code> <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: selected population</p> Source code in <code>pangadfs/select.py</code> <pre><code>def select(self, \n           *, \n           population: np.ndarray, \n           population_fitness: np.ndarray,\n           n: int,\n           method: str = 'roulette',\n           **kwargs) -&gt; np.ndarray:\n    \"\"\"Select individuals in population using specified method.\n\n    Args:\n        population (np.ndarray): the population to mutate. Shape is n_individuals x n_chromosomes.\n        population_fitness (np.ndarray): the population fitness. Is a 1D array same length as population.\n        n (int): total number of individuals to select\n        method (str): 'roulette', 'su', 'scaled'; default 'roulette'\n        **kwargs: keyword arguments for plugins\n\n    Returns:\n        np.ndarray: selected population\n\n    \"\"\"\n    dispatch = {\n        'roulette': self._roulette_wheel,\n        'sus': self._sus,\n        'rank': self._rank,\n        'tournament': self._tournament,\n        'scaled': self._scaled,\n        'fittest': self._fittest\n    }        \n\n    params = {\n        'population': population,\n        'population_fitness': population_fitness,\n        'n': n\n    }\n\n    return dispatch.get(method, self._roulette_wheel)(**params, **kwargs)\n</code></pre>"},{"location":"validate-reference/","title":"Validate Reference","text":"<p>The validate module provides validation classes to ensure lineups meet various constraints and requirements.</p>"},{"location":"validate-reference/#available-validators","title":"Available Validators","text":""},{"location":"validate-reference/#general-validation","title":"General Validation","text":""},{"location":"validate-reference/#duplicatesvalidate","title":"DuplicatesValidate","text":"<p>Removes lineups that contain duplicate players.</p> <p>Use case: Ensure no player appears multiple times in a lineup.</p> <p>Key features: - Efficient duplicate detection using sorted arrays - Handles both internal duplicates (within lineup) and external duplicates (between lineups) - Optimized for large populations</p>"},{"location":"validate-reference/#flexduplicatesvalidate","title":"FlexDuplicatesValidate","text":"<p>Validates that FLEX positions don't duplicate players already used in other positions.</p> <p>Use case: Ensure FLEX players are truly additional and don't overlap with required positions.</p> <p>Key features: - Vectorized approach for efficiency - Handles complex position mapping scenarios - Prevents invalid lineups where FLEX duplicates required positions</p>"},{"location":"validate-reference/#salaryvalidate","title":"SalaryValidate","text":"<p>Ensures all lineups meet salary cap constraints.</p> <p>Use case: Filter out lineups that exceed the salary cap.</p> <p>Key features: - Fast salary calculation using numpy operations - Configurable salary cap - Efficient boolean indexing for filtering</p>"},{"location":"validate-reference/#position-validation","title":"Position Validation","text":""},{"location":"validate-reference/#positionvalidate","title":"PositionValidate","text":"<p>Validates that lineups meet position requirements (QB, RB, WR, TE, etc.).</p> <p>Use case: Ensure lineups have the correct number of players at each position.</p> <p>Key features: - Flexible position mapping support - FLEX position handling - Comprehensive position requirement checking</p> <p>Parameters: - <code>posmap</code>: Position requirements (e.g., {'QB': 1, 'RB': 2, 'WR': 3, 'TE': 1, 'DST': 1, 'FLEX': 1}) - <code>position_column</code>: Column name for positions in player pool - <code>flex_positions</code>: Positions that can fill FLEX slots (default: ('RB', 'WR', 'TE'))</p>"},{"location":"validate-reference/#positionvalidateoptimized","title":"PositionValidateOptimized","text":"<p>Optimized version of position validation using vectorized operations.</p> <p>Use case: Same as PositionValidate but with better performance for large populations.</p> <p>Key features: - Vectorized validation for better performance - Pre-computed position arrays for fast lookup - Same functionality as PositionValidate with speed improvements</p>"},{"location":"validate-reference/#usage-examples","title":"Usage Examples","text":""},{"location":"validate-reference/#basic-validation-setup","title":"Basic Validation Setup","text":"<pre><code>from pangadfs.validate import DuplicatesValidate, SalaryValidate, PositionValidate\n\n# Set up validators\nvalidators = [\n    DuplicatesValidate(),\n    SalaryValidate(),\n    PositionValidate()\n]\n\n# Apply validation in sequence\nfor validator in validators:\n    population = validator.validate(\n        population=population,\n        salaries=salaries,\n        salary_cap=50000,\n        pool=player_pool,\n        posmap={'QB': 1, 'RB': 2, 'WR': 3, 'TE': 1, 'DST': 1, 'FLEX': 1},\n        position_column='pos',\n        flex_positions=('RB', 'WR', 'TE')\n    )\n</code></pre>"},{"location":"validate-reference/#using-with-geneticalgorithm","title":"Using with GeneticAlgorithm","text":"<pre><code>from stevedore.named import NamedExtensionManager\n\n# Set up validation extension manager\nemgrs = {\n    'validate': NamedExtensionManager(\n        namespace='pangadfs.validate',\n        names=['validate_salary', 'validate_duplicates', 'validate_positions'],\n        invoke_on_load=True,\n        name_order=True\n    )\n}\n\nga = GeneticAlgorithm(ctx=ctx, extension_managers=emgrs)\n</code></pre>"},{"location":"validate-reference/#module-consolidation","title":"Module Consolidation","text":"<p>Note: All validation classes are now consolidated in the single <code>pangadfs.validate</code> module. Previously, position validation classes were in a separate <code>validate_positions</code> module, but they have been moved for better organization and easier imports.</p> <p>Migration: If you were previously importing from <code>pangadfs.validate_positions</code>, simply change your imports to use <code>pangadfs.validate</code>:</p> <pre><code># Old (no longer works)\nfrom pangadfs.validate_positions import PositionValidate\n\n# New (current)\nfrom pangadfs.validate import PositionValidate\n</code></pre>"},{"location":"validate-reference/#api-reference","title":"API Reference","text":""},{"location":"validate-reference/#pangadfs.validate","title":"<code>pangadfs.validate</code>","text":""},{"location":"validate-reference/#pangadfs.validate.FlexDuplicatesValidate","title":"<code>FlexDuplicatesValidate()</code>","text":"<p>               Bases: <code>ValidateBase</code></p> <p>Validates that FLEX positions don't duplicate other positions. This replaces the expensive duplicate checking that was in PopulateDefault. Uses a more efficient vectorized approach.</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"validate-reference/#pangadfs.validate.PositionValidate","title":"<code>PositionValidate()</code>","text":"<p>               Bases: <code>ValidateBase</code></p> <p>Validates that lineups meet position requirements</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"validate-reference/#pangadfs.validate.PositionValidate.validate","title":"<code>validate(*, population, pool, posmap, position_column='pos', flex_positions=('RB', 'WR', 'TE'), **kwargs)</code>","text":"<p>Validates that each lineup meets position requirements</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>Array of lineups (population_size, lineup_size)</p> required <code>pool</code> <code>DataFrame</code> <p>Player pool DataFrame with position information</p> required <code>posmap</code> <code>Dict[str, int]</code> <p>Position requirements (e.g., {'QB': 1, 'RB': 2, 'WR': 3, 'TE': 1, 'DST': 1, 'FLEX': 1})</p> required <code>position_column</code> <code>str</code> <p>Column name for positions in pool</p> <code>'pos'</code> <code>flex_positions</code> <code>tuple</code> <p>Positions that can fill FLEX slots</p> <code>('RB', 'WR', 'TE')</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Filtered population with only valid lineups</p> Source code in <code>pangadfs/validate.py</code> <pre><code>def validate(self, *, \n             population: np.ndarray,\n             pool: pd.DataFrame,\n             posmap: Dict[str, int],\n             position_column: str = 'pos',\n             flex_positions: tuple = ('RB', 'WR', 'TE'),\n             **kwargs) -&gt; np.ndarray:\n    \"\"\"\n    Validates that each lineup meets position requirements\n\n    Args:\n        population: Array of lineups (population_size, lineup_size)\n        pool: Player pool DataFrame with position information\n        posmap: Position requirements (e.g., {'QB': 1, 'RB': 2, 'WR': 3, 'TE': 1, 'DST': 1, 'FLEX': 1})\n        position_column: Column name for positions in pool\n        flex_positions: Positions that can fill FLEX slots\n\n    Returns:\n        np.ndarray: Filtered population with only valid lineups\n    \"\"\"\n    if len(population) == 0:\n        return population\n\n    # Get position information for all players\n    player_positions = pool[position_column].to_dict()\n\n    valid_lineups = []\n\n    for lineup in population:\n        if self._is_lineup_valid(lineup, player_positions, posmap, flex_positions):\n            valid_lineups.append(lineup)\n\n    if len(valid_lineups) == 0:\n        # If no valid lineups, return empty array with correct shape\n        return np.empty((0, population.shape[1]), dtype=population.dtype)\n\n    return np.array(valid_lineups)\n</code></pre>"},{"location":"validate-reference/#pangadfs.validate.PositionValidateOptimized","title":"<code>PositionValidateOptimized()</code>","text":"<p>               Bases: <code>ValidateBase</code></p> <p>Optimized version using vectorized operations where possible</p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"validate-reference/#pangadfs.validate.PositionValidateOptimized.validate","title":"<code>validate(*, population, pool, posmap, position_column='pos', flex_positions=('RB', 'WR', 'TE'), **kwargs)</code>","text":"<p>Validates that each lineup meets position requirements using optimized approach</p> Source code in <code>pangadfs/validate.py</code> <pre><code>def validate(self, *, \n             population: np.ndarray,\n             pool: pd.DataFrame,\n             posmap: Dict[str, int],\n             position_column: str = 'pos',\n             flex_positions: tuple = ('RB', 'WR', 'TE'),\n             **kwargs) -&gt; np.ndarray:\n    \"\"\"\n    Validates that each lineup meets position requirements using optimized approach\n    \"\"\"\n    if len(population) == 0:\n        return population\n\n    # Create position mapping array for fast lookup\n    max_player_id = max(pool.index.max(), population.max()) + 1\n    position_array = np.full(max_player_id, '', dtype='U5')\n\n    for player_id, pos in zip(pool.index, pool[position_column]):\n        position_array[player_id] = pos\n\n    # Vectorized validation\n    valid_mask = np.array([\n        self._is_lineup_valid_vectorized(lineup, position_array, posmap, flex_positions)\n        for lineup in population\n    ])\n\n    return population[valid_mask]\n</code></pre>"},{"location":"validate-reference/#pangadfs.validate.SalaryValidate","title":"<code>SalaryValidate()</code>","text":"<p>               Bases: <code>ValidateBase</code></p> Source code in <code>pangadfs/base.py</code> <pre><code>def __init__(self):\n    logging.getLogger(__name__).addHandler(logging.NullHandler())\n</code></pre>"},{"location":"validate-reference/#pangadfs.validate.SalaryValidate.validate","title":"<code>validate(*, population, salaries, salary_cap, **kwargs)</code>","text":"<p>Ensures valid individuals in population</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>ndarray</code> <p>the population to validate</p> required <code>salaries</code> <code>ndarray</code> <p>1D where indices are in same order as player indices</p> required <code>salary_cap</code> <code>int</code> <p>the salary cap, e.g., 50000 or 60000</p> required <code>**kwargs</code> <p>keyword arguments for plugins</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: same width as population, likely has less rows</p> Source code in <code>pangadfs/validate.py</code> <pre><code>def validate(self,\n             *, \n             population: np.ndarray,\n             salaries: np.ndarray,\n             salary_cap: int, \n             **kwargs) -&gt; np.ndarray:\n    \"\"\"Ensures valid individuals in population\n\n        Args:\n            population (np.ndarray): the population to validate\n            salaries (np.ndarray): 1D where indices are in same order as player indices\n            salary_cap (int): the salary cap, e.g., 50000 or 60000\n            **kwargs: keyword arguments for plugins\n\n        Returns:\n            np.ndarray: same width as population, likely has less rows\n\n    \"\"\"\n    if len(population) == 0:\n        return population\n\n    # Use take for potentially faster indexing\n    salary_matrix = np.take(salaries, population)\n    popsal = np.sum(salary_matrix, axis=1)\n\n    # Use nonzero for potentially faster boolean indexing\n    valid_indices = np.nonzero(popsal &lt;= salary_cap)[0]\n    return population[valid_indices]\n</code></pre>"}]}