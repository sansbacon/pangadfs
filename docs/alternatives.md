# Alternatives, Inspiration and Comparisons

**pangadfs** was inspired by my experience using web-based optimizers (WBOs), such as FantasyLabs and Rotogrinders, as well as python/R libraries for integer programming, such as google or-tools, PuLP, and lpSolve.

There were a couple of things I did not like about WBOs: (1) they are a black box and (2) they use a rules-based approach to lineup construction. For most people, the WBOs enable them to do things they either lack the tecnhical ability to do, or, even if they have the requisite technical skills, they free them up to focus on creating lineups rather than debugging algorithms. I enjoy programming more than I enjoy creating lineups, and this is a fascinating domain in which to build my skills and test out ideas. I also found that the dominant paradigm for WBOs was a rules-based approach, meaning that you construct lineups by specifying a minimum and maximum ownership for individual players and requirements about combinations of players that are allowed or disallowed. To me, this puts the cart before the horse -- how can I know how to allocate ownership or what other rules to use before I see a range of lineup options. I think what ends up happening when you use these products is that you have intuitions (that may also be backed by data) that you encapsulate as a rule, and then you use other rules to try to cabin the side effects of your initial rule. For example, it is well known that QB performance has a strong positive correlation with WR1 scoring, so you create a stacking rule, but then every lineup ends up with the same QB-WR1 combination, so then you offset that with ownership rules. My experience was that I ended up with a very complex set (of seemingly arbitrary) rules and it was very difficult to administer at scale.

Dissatisfied with web-based optimizers, I turned to python/R libraries for integer programming. After using these libraries (and those built on top of them, such as pydfs-lineup-optimizer), I faced a couple of frustrations. First, the user interface for some of them is, shall we say, less than optimal. For example, lpSolve required a vector of directions for constraints that became very difficult to manage or maintain as the number of variables or constraints grew. Second, even libraries that have a good interface, such as PuLP, still require you to learn an entirely different language of linear programming and then translate those concepts to python. I found that, as the number of constraints increased, it became very difficult to understand how the program was working under the hood. To boot, there are also performance problems the more constraints you add and as you want to generate more lineups. pydfs-lineup-optimizer is a well-designed library that takes away some of these issues, but, in the end, to make any meaningful contributions to the code, you need a very strong understanding of linear programming.

As with many projects, I told myself "there has to be a better way." I first had to find an alternative to linear programming as the core optimizer. I settled on a genetic algorithm because the concepts are easy to understand and it can be implemented in numpy, where vectorized operations allow for solid performance. Instead of having to learn an entirely different language (integer programming) and then translate it to python, I could write code in python / numpy.

After learning more about genetic algorithms, I realized that they address my concerns (described above) about rule-based approaches. Instead of rules, genetic algorithms use penalties to nudge solutions in a particular direction. I also found out that they are excellent for quickly generating large numbers of viable lineups (making 10000 lineups is **fast**), whereas integer programming slows down the more lineups you try to generate. 

The last advantage I found was that the genetic algorithm is amenable to a plugin architecture. I found the stevedore plugin library, which allows me or other developers to create plugins to replace the core functionality of one or more steps of the genetic algorithm. This flexibility is straightforward, because at its core, the algorithm is passing 2D and 1D numpy arrays from function to function. I quickly developed plugins for showdown mode, a structured configuration system, and an interface to interact with pydfs-lineup-optimizer.

These were my reasons for creating pangadfs. I look forward to your feedback and plugin ideas!